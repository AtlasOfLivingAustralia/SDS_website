---
title: "Map multiple species distributions on one map with hexagons & points"
description: |
  Visualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a method that allows users to get an overview of multiple species distributions in an area using a novel twist on the commonly used hexbin map.  
author:
  - name: "Callum Waite"
  - name: "Shandiya Balasubramaniam"
date: "2023-12-18"
title-block-banner: "#B8573E"
include-after-body: _footer.html
toc: true
toc-location: left
toc-depth: 3
categories:
  - Eukaryota
  - Animalia
  - Chordata
  - Aves
  - Summaries
  - Maps
image: map_hexbin-points.png
draft: true
freeze: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->

```{=html}
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>
```
<!-- Author card -->

::: author-card
::: author-card-text
#### Author

[Callum Waite](https://labs.ala.org.au/people/Waite_Callum/index.html)\
[Shandiya Balasubramaniam](https://labs.ala.org.au/people/Balasubramaniam_Shandiya/index.html)

#### Date

27 November 2023
:::

::: author-card-image
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/callum.jpg")
```
:::

::: author-card-image
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.png")
```
:::
:::

<!------------------------ Post starts here ------------------------>

Visualisations of species distributions can be very simple yet effective ways of conveying biological and ecological information, such as range, habitat and population size. 

Representing more than one species distribution in a single figure can be difficult, though, especially where there are areas of overlap. Points and colour-filled polygons will obscure each other even with a degree of transparency, while densities and shaded regions can only show one species at a time. <!--[suggest to cut for brevity] Comparisons can be made by providing two single distribution figures side-by-side, but it can be inconvenient to observe range overlaps in this manner. -->

Here, we demonstrate a method to visualise distributions of multiple species with overlapping ranges on the same map, with only a small loss in resolution. The technique is a novel twist on the commonly used [hexbin map](https://r-graph-gallery.com/hexbin-map.html): instead of using a colour fill to represent presence/absence or counts within each hexagon, we use multiple coloured points within each hexagon to represent presence/absence of species, allowing users to get a broad overview of how multiple species are distributed across an area.

This method requires a number of key steps to build the elements of the entire figure:

  *  Downloading occurrence records for our species of interest
  *  Creating a hex grid over the area of interest for those species, and trimming it to only include those hexes that contain occurrences
  *  Within each hex, arranging and assigning points to species

After creating these components, the basemap, hex grid and species points can then be combined into the final figure.

Let's begin by loading the R packages we'll be using.

```{r}
#| output: FALSE
library(galah)
library(ggtext)
library(ozmaps)
library(sf)
library(showtext)
library(stringr)
library(tidyverse)
```

We'll use the [{galah} package](https://galah.ala.org.au) to download occurrence records from the [Atlas of Living Australia (ALA)](https://www.ala.org.au). To do this, you'll need to [register your email address with the ALA](https://auth.ala.org.au/userdetails/registration/createAccount), then pass it to {galah} using `galah_config()`.

```{r}
#| include: FALSE
galah_config(email = "callumwaite2000@gmail.com")
```

```{r}
#| eval: FALSE
galah_config(email = "your-email@email.com")
```

## Download data

Since our goal here is to map distributions of multiple species, we've chosen honeyeaters from the genus *Melithreptus*: this is a distinctive group of 7 small- to medium-sized, short-billed and square-tailed honeyeaters with overlapping distributions across Australia.

::: {layout-ncol="3" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/a/2/5/323bd0bc-545f-48fa-85aa-eb77dcd052a3/original" class = "rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/b/7/c/a/d96d11b4-4150-48c2-990a-20b70064ac7b/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/6/1/5/2/03f17fd7-a256-44c8-a377-011784ef2516/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Melithreptus gularis* - Black-chinned Honeyeater (Graham Winterflood CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/53209bab-d2c1-4aab-ace7-e2de155389ae), Middle: [*Melithreptus chloropsis* - Gilbert's Honeyeater (Wacrakey CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/a0792deb-18a9-4e59-9419-add4d7b5d0c9), Right: [*Melithreptus validirostris* - Strong-billed Honeyeater (Bird Explorers CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/26edb457-4c80-4073-a6a8-176e68cf431e)
:::

We can get taxonomic information about this group using `atlas_species()`...

```{r}
melithreptus <- galah_call() |>
  galah_identify("Melithreptus") |>
  atlas_species()

melithreptus
```

... and then use this information to download occurrence records for the 7 species. We'll apply the general data quality profile to filter out low quality records, pass in the list of species we're interested in with `galah_identify()`, filter records to 2022[^1] that also have spatial coordinates, and fall within one of the [IBRA bioregions](https://www.dcceew.gov.au/environment/land/nrs/science/ibra) as a proxy for Australian records only.

[^1]: There are over half a million records from this genus in the ALA, so restricting our download to records from 2022 significantly speeds things up!

**DAX: not sure what the convention is here - do we store downloaded data as RDS files and load them instead of downloading each time? Also I can't remember where they get saved**

**C & S: You can do either. If the data is large, it's probably best to load it like you have here. To avoid saving large datasets in the github repo, you should save the data in posts/data/. The contents of this folder do not push onto GitHub. To allow everyone to have access to the data, you should also save a copy of it on Teams in the Data/ala-labs/data folder. This contains all the data for every post, and people can copy these files into their local ala-labs/posts/data folder to render posts.**
*CW: I've copied the .RDS file to 'posts/data' and also added it to Teams*

```{r}
#| eval: true
#| echo: false
species_occ <- readRDS(here::here("posts", "data", "2023-11-14_hex_point_maps", "species_occ.RDS"))
```

```{r}
#| eval: false
#| echo: true
species_occ <- galah_call() |>
  galah_apply_profile(ALA) |>
  galah_identify(melithreptus$species) |>
  galah_filter(year == 2022,
               !is.na(cl1048),  # IBRA bioregions
               !is.na(decimalLatitude),
               !is.na(decimalLongitude)) |>
  galah_select(decimalLatitude,
               decimalLongitude,
               species, 
               scientificName) |> 
  atlas_occurrences()

head(species_occ)
```

```{r}
#| echo: false
head(species_occ)
```

Since we're going to be performing a few spatial operations to assign species to hexagons, we'll also convert the `species_occ` dataframe into a simple features object, with the latitude and longitude columns represented as points in a geometry column named `occ_geometry`.

```{r}
species_occ_sf <- species_occ |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), 
           crs = 4326) |> 
  st_set_geometry("occ_geometry")

```

## Generate hex grid

Next, we'll set up a grid of hexagons across terrestrial Australia, which we'll use as bins for plotting summaries of species occurrence. `st_make_grid()` has arguments for specifying the size, type, and orientation of polygons in the grid, and this is initially created across the entire bounding box of the supplied shapefile (here the `ozmap_country` shapefile). We can then use a spatial filter to exclude any hexagons that do not intersect with the shapefile polygon boundary, and assign a unique identifier to each remaining hexagon.

```{r}
hex_grid <- st_make_grid(ozmap_country,
                         cellsize = 2,
                         what = "polygons",
                         square = FALSE,
                         flat_topped = TRUE) |>  
  st_as_sf() |>   
  st_filter(ozmap_country) |> 
  st_set_geometry("hex_geometry") |> 
  st_transform(4326) |> 
  rowid_to_column(var = "hex_id")
```

Our grid of hexagons now looks like this:

```{r}
#| eval: true
#| echo: false
ggplot() +
  geom_sf(data = ozmap_states, 
          colour = "darkgrey", 
          fill = NA, 
          linewidth = 0.3) +
  geom_sf(data = hex_grid, 
          fill = NA, 
          col = "deepskyblue4", 
          linewidth = 0.4) +
  theme_void()
```

### Remove empty hexes

Not every hexagon will contain an occurrence record, though, so let's remove empty hexagons with a spatial join (which behaves similarly to `dplyr::left_join()` for spatial objects). This returns an object with the same number of rows as our original download of occurrence records, with additional columns containing information on which polygon each species occurs in.

```{r}
hex_with_species <- st_join(x = hex_grid, 
                            y = species_occ_sf,
                            join = st_intersects,
                            left = FALSE)

head(hex_with_species, n = 10)
```

This means any hexagons we initially created in the grid that don't intersect with occurrence records have been removed:

```{r}
#| eval: true
#| echo: false
ggplot() +
  geom_sf(data = ozmap_states, 
          colour = "darkgrey", 
          fill = NA, 
          linewidth = 0.3) +
  geom_sf(data = count(hex_with_species, hex_id, hex_geometry), 
          fill = NA, 
          col = "deepskyblue4", 
          linewidth = 0.4) +
  theme_void()
```

### Set up positions

As some hexagons will contain occurrence records for more than one species, we need a way to display these overlaps. We'll do this by setting up 7 positions in each hexagon, 1 for each species, and assign each species a position and colour so they can be visually differentiated.

**Would it be possible to add colour to the final hexagon? That way it looks exactly like what users will eventually see if they follow these steps? Or does this not suit the point of the explanation below?**

The figure below summarises how we'll do this: for each hexagon remaining in the grid, we'll generate a smaller hexagon, then get the coordinates of each vertex and centroid of the smaller hexagon. Eventually, we'll end up with a point for each species.

```{r}
#| eval: true
#| echo: false
library(patchwork)

big_hex <- st_polygon(list(rbind(
  c(-1, 0),
  c(-0.5, sqrt(0.75)),
  c(0.5, sqrt(0.75)),
  c(1, 0),
  c(0.5,-sqrt(0.75)),
  c(-0.5,-sqrt(0.75)),
  c(-1, 0))))

small_hex <- st_buffer(big_hex, -0.3)

small_hex_vertices <- small_hex |>
  st_coordinates() |>
  as_tibble() |>
  st_as_sf(coords = c("X", "Y"), remove = FALSE) |> 
  rowid_to_column() |> 
  mutate(vertex_id = if_else(rowid %in% c(2:6), as.character(rowid), "1, 7"))

# 1. original hex
p1 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  labs(subtitle = "Original hex") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 2. smaller hex
p2 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex, fill = NA, linewidth = 1, colour = "deepskyblue3") +
  labs(subtitle = "Smaller hex") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 3. vertices
p3 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 3, colour = "deepskyblue3") +
  labs(subtitle = "Smaller hex vertices") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 4. vertex numbers
p4 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 3, colour = "deepskyblue3") +
  geom_text(data = small_hex_vertices, aes(X, Y, label = vertex_id), nudge_y = 0.16) +
  labs(subtitle = "Numbered vertices") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 5. with centroid
p5 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 3, colour = "deepskyblue3") +
  geom_sf(data = st_centroid(small_hex), size = 3, colour = "deepskyblue3") +
  geom_text(data = small_hex_vertices[c(1:6),], aes(X, Y, label = rowid), nudge_y = 0.16) +
  geom_sf_text(data = st_centroid(small_hex), aes(label = "7"), nudge_y = 0.16) +
  labs(subtitle = "Numbered vertices and centroid") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))
```

```{r}
#| eval: true
#| echo: false
#| column: page
#| fig-align: center
#| fig-height: 2
#| fig-width: 10
p1 + p2 + p3 + p4 + p5 + plot_layout(ncol = 5)
```

Let's start by extracting the unique identifiers and spatial coordinates for every hexagon containing an occurrence record[^2]. Each `hex_id` refers to one of the hexagons on our Australia map.

[^2]: Using `distinct()` produces an identical result to `count()` here, but is far slower because checking for distinct values in the geometry column is computationally intensive. If your dataframe has fewer rows, you could also do this: `hex_with_species |> select(hex_id, hex_geometry) |> distinct()`.

```{r}
unique_hex <- hex_with_species |> 
  count(hex_id, hex_geometry) |> 
  select(-`n`)
unique_hex
```

Now let's arrange points within each hexagon using a custom function. In our function we'll create a smaller hexagon within each original hexagon using `st_buffer()`, extract the coordinates of it's vertices using `st_coordinates()`, and assign an integer to each vertex ranging from 1 to 7. We can use `pmap()` to iterate this for every hexagon in the grid.

<aside>Each hexagon is formed as a closed (rather than open) polygon, whereby the vertices are joined in the following order: 1-2-3-4-5-6-1. As a result, there are 7 rows of coordinates although there are only 6 vertices in each hexagon; the information in the first and seventh rows is duplicated. **Is the reason for this because R has created a closed hexagon rather than an open one? Might be worth tacking that info on?** *CW - looks like it is specified as a closed polygon in the first sentence, but I've added the "(rather than open)"?*</aside> 

**The sentence below is a little confusing. Maybe simplify? Or it might be good to explain more about what each column contains in the dataframe. This could help the reader more quickly absorb that there are 7 rows for each `hex_id`, then understand what's in `hex_geometry`, etc**

PREVIOUS: *The resulting dataframe has a geometry column with spatial coordinates for each of the 7 vertices associated with the smaller hexagons we generated.*

**NEW + added comments (maybe move below code block?):** In the resulting dataframe, `vertex_coords`, there are 7 rows for each large hexagon: one for each of the vertices associated with the smaller hexagons we generated. The large hexagons are identified by `hex_id` and `hex_geometry`. Each inner vertex point, numbered by `vertex_position`, is described by a `geometry` column with spatial coordinates.

```{r}
vertex_coords <- unique_hex |> 
  mutate(vertices = pmap(
    .l = list(x = hex_geometry),
    .f = function(x) {
      x |>
        st_buffer(dist = -0.4) |>     # set size of smaller hexagon
        st_coordinates() |>           # extract coordinates
        as_tibble() |>
        st_as_sf(coords = c("X", "Y")) |>
        select(-L1, -L2) |>            # tidy output of `st_coordinates()`
        mutate(vertex_position = 1:7) # number vertices consistently
    })) |> 
  unnest(cols = vertices)

head(vertex_coords, n = 10)
```

It's worth noting that we define the size of the smaller hexagon with the `dist` argument in `st_buffer()`, which changes based on the `cellsize` of the original hexagon we created (in our five-hexagon figure above, we set `cellsize` = 2). Depending on the number of species you'd like to fit within each polygon and the shape of the polygon you've chosen, you may need to try out different values of `cellsize` and `dist` to find combinations that work best for your visualisation.

Since we need 7 positions in each hexagon (to fit a maximum of 7 species), and we conveniently have a duplicated row for every hexagon, we can mutate the repeated 7th vertex to hold the coordinates of the centroid of each hexagon. **it's not clear why?**

**CW edit to replace above para:** We require seven positions in each hexagon (to fit a maximum of 7 species) and conveniently have seven rows for each hexagon in `vertex_coords`. However, recall that `vertex_position` 1 and 7 represent the same vertex of the closed hexagon shape. We can therefore mutate this repeated 7th vertex to hold the coordinates of the centroid of each hexagon, giving us seven distinct positions.

**I've shown the output of this chunk, but it might need editing to show the reader exactly what you've done**

```{r}
vertex_centroid_coords <- vertex_coords |> 
  mutate(geometry = ifelse(vertex_position == 7,      # replace 7th vertex...
                           st_centroid(hex_geometry), # ...with hex centre
                           geometry)) |> 
  st_drop_geometry() |> # remove hex_geometry column
  st_as_sf(crs = 4326)

head(vertex_centroid_coords, n = 7)
```

### Assign species to positions

**I appreciate the brevity of this section but it's not very clear what is happening in these steps for a reader. For example, the string replacement in the first chunk uses regex which lots of people don't understand. The second step has some cleaning followed by 2 different joins. It might be worth showing how these joins affect what eventually becomes the final dataframe by separating steps and showing the output. Other times, some notes in the code could help too**

*PREV: Following a bit of tidying of our `melithreptus` dataframe (created earlier using `atlas_species()`) to remove subgenera from species names and ensure all species have a vernacular name, all we have to do now is assign a numbered position to each species...*

**NEW (CW):** Our `melithreptus` dataframe (created earlier using `atlas_species()`) requires a small amount of tidying to be compatible with the rest of our data. The `species` column still contains subgenera which we can remove with regular expressions (regex)[^3]. We also need to ensure all species have a vernacular name, noting that *Melithreptus chloropsis* is currently lacking one in the ALA database. We can then assign a numbered position to each species[^4].

[^3]: Regular expressions, or regex, are used to match (and replace) specific patterns in strings. Here, we want to remove the bracketed subgenera in species names (e.g. `"Melithreptus (Melithreptus) affinis"` to `"Melithreptus  affinis"`), and we do this using the line `species = str_replace_all(species, "\\(.*?\\)\\s*", "")`. It is not
crucial to understand how this regex works, but if you are curious: the expression searches through all strings in the `species` column and inserts the empty string (`""`) in place of any bracketed (`"\\("` and `"\\)"`) content (`".*?"`) that is immediately followed by a white-space (`"\\s*"`). 

[^4]: Here we assign the positions simply with `vertex_position = c(1:7)`, however you can reorder the dataframe or this position vector to have more control over which point in the hexagon each species is assigned. For instance, you might wish to do this to separate similar colours within the hexagon, or to assign the most widely distributed species to the centre point.

```{r}
species_data <- melithreptus |>
  select(species, vernacular_name) |>
  mutate(species = str_replace_all(species, "\\(.*?\\)\\s*", ""),
         vernacular_name = if_else(species == "Melithreptus chloropsis", 
                                   "Gilbert's Honeyeater",
                                   vernacular_name),
         vertex_position = c(1:7))

species_data
```

Our final step is to bring our three dataframes (`hex_with_species`, `species_data`, `vertex_centroid_coords`) together with `left_join()`. We can perform these joins with some key identifying columns, namely `hex_id`, `species` and `vertex_position`. We begin with our distinct hexagon and species combinations and join the species positions and common names using the `species` field...

```{r}
species_points_a <- hex_with_species |>
  st_drop_geometry() |>
  select(hex_id, species) |>
  distinct() |> 
  left_join(species_data,
            by = join_by(species))

head(species_points_a, n = 10)
```

...and follow this with another join to bring in the coordinates of each species point inside the hexagons. These are uniquely identified by their `hex_id` and `vertex_position`, and we can assign the species to each vertex using the `vertex_position` column we also created in `species_data`.

```{r}
species_points <- species_points_a |>
  left_join(vertex_centroid_coords,
            by = join_by(vertex_position, hex_id)) |> 
  st_as_sf(crs = 4326)

head(species_points, n = 10)
```

## Map

We can now plot our three separate spatial layers - the basemap, hexagons, and species points - together as simply as possible to check we've built them all correctly...

```{r}
ggplot() +
  geom_sf(data = ozmap_states, fill = NA) +
  geom_sf(data = unique_hex, fill = NA) +
  geom_sf(data = species_points, aes(colour = vernacular_name)) +
  lims(x = c(112, 155), y = c(-46, -8)) +
  theme_void()
```

...and seeing that we have, we can now add some finishing touches to make our plot more aesthetically pleasing, as well as colour-blind friendly using a colour scheme by [Paul Tol](https://personal.sron.nl/~pault/).

```{r}
#| echo: true
#| code-fold: true
#| fig-height: 7
#| fig-width: 10
#| column: page
#| fig-align: center

font_add_google("Montserrat")
showtext_auto(enable = TRUE)

tol_muted <- c("#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#AA4499", "#44AA99")

ggplot() +
  geom_sf(data = ozmap_states, 
          fill = NA, colour = "#ababab", linewidth = 0.3) +
  geom_sf(data = unique_hex, 
          fill = "#efefef55", colour = "#777777", linewidth = 0.5) +
  geom_sf(data = species_points, aes(colour = vernacular_name), 
          size = 2.3) +
  scale_colour_manual(
    values = tol_muted,
    guide = guide_legend(title = "*Melithreptus* &#0020; species",
                         override.aes = list(size = 4))
  ) +
  lims(x = c(112, 155), y = c(-46, -8)) +
  theme_void() +
  theme(legend.title = element_markdown(family = "Montserrat", size = 24),
        legend.text = element_text(family = "Montserrat", size = 20),
        legend.spacing.x = unit(0, "in"))
```

## Final Thoughts

This visualisation is a novel way to show range overlaps and distributions of multiple species at once. A key strength is the consistency of the repeatable hex unit - the fixed positions and colours of the species points within hexagons make it easier to follow patterns within or between species.

This is also a very flexible method - it is easily customisable with regards to 1) the size, shape (hexagons vs squares) and orientation of the polygons; 2) the colours and orientations of points within the hexagons; and 3) the spatial scale of the base map. 

Consider also that you do not necessarily need to use exactly seven different species/taxa - with a bit of creativity, it is possible to fit any number of points from 2-9 into a hexagon (2-7) or square symmetrically...

```{r}
#| echo: FALSE
#| fig-height: 1
big_hex <- st_polygon(list(rbind(
  c(-1, 0),
  c(-0.5, sqrt(0.75)),
  c(0.5, sqrt(0.75)),
  c(1, 0),
  c(0.5,-sqrt(0.75)),
  c(-0.5,-sqrt(0.75)),
  c(-1, 0))))

small_hex <- st_buffer(big_hex, -0.4)

small_hex_vertices <- small_hex |>
  st_coordinates() |>
  as_tibble() |>
  rowid_to_column() |>
  mutate(X = ifelse(rowid == 7, 0, X)) |>
  st_as_sf(coords = c("X", "Y"), remove = FALSE) |> 
  select(rowid)

# 3. vertices
h2 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices[c(2,5),], size = 5, colour = "deepskyblue3") +
  theme_void()

h3 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices[c(2,4,6),], size = 5, colour = "deepskyblue3") +
  theme_void()

h4 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices[c(2,4,6,7),], size = 5, colour = "deepskyblue3") +
  theme_void()

h5 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices[c(2,3,5,6,7),], size = 5, colour = "deepskyblue3") +
  theme_void()

h6 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices[1:6,], size = 5, colour = "deepskyblue3") +
  theme_void()

h7 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 5, colour = "deepskyblue3") +
  theme_void()

(h2 + h3 + h4 + h5 + h6 + h7) + plot_layout(ncol = 6)
```

<details>

<summary style="color: #E06E53;">

Expand for session info

</summary>

```{r, echo = FALSE}
library(sessioninfo)
# save the session info as an object
pkg_sesh <- session_info(pkgs = "attached")
# print it out
pkg_sesh
```

</details>
