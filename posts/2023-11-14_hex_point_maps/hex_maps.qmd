---
title: "Hex maps something something"
description: |
  Visualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a method that allows users to get an overview of multiple species distributions in an area using a novel twist on the commonly used hexbin map.  
author:
  - name: "Callum Waite"
  - name: "Shandiya Balasubramaniam"
date: "2023-12-18"
title-block-banner: "#B8573E"
include-after-body: _footer.html
toc: true
toc-location: left
toc-depth: 3
categories:
  - Eukaryota
  - Animalia
  - Chordata
  - Aves
  - Summaries
  - Maps
image: tbd
draft: true
freeze: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->

```{=html}
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>
```
<!-- Author card -->

::: author-card
::: author-card-text
#### Author

[Callum Waite](https://labs.ala.org.au/people/Waite_Callum/index.html)\
[Shandiya Balasubramaniam](https://labs.ala.org.au/people/Balasubramaniam_Shandiya/index.html)

#### Date

27 November 2023
:::

::: author-card-image
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/callum.jpg")
```
:::

::: author-card-image
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.jpg")
```
:::
:::

<!------------------------ Post starts here ------------------------>

Visualisations of species distributions can be very simple yet effective ways of conveying biological and ecological information, such as range, habitat, population size, fragmentation, and migration. This information can be represented as points, hulls, densities, and binned regions, to name but a few.

**DAX: we could link to labs posts that show these methods?**

Representing more than one species distribution in a single figure can be difficult, though, especially where there are areas of overlap. Points and hulls will obscure each other even with a degree of transparency, while densities and shaded regions can only show one species at a time. Comparisons can be made by providing two single distribution figures side-by-side, but it can be inconvenient to observe range overlaps in this manner.

Here, we demonstrate a method to visualise distributions of multiple species with overlapping ranges on the same map, with only a small loss in resolution. The technique is a novel twist on the commonly used [hexbin map](https://r-graph-gallery.com/hexbin-map.html): instead of using a colour fill to represent presence/absence or counts within each hexagon, we use multiple coloured points within each hexagon to represent presence/absence of species, allowing users to get a broad overview of how multiple species are distributed across an area.

**ADD A SECTION HERE EXPLAINING WHAT THE STEPS ARE GOING TO BE**
e.g. We'll do this by: 
- download records for species of interest  
- create a hex grid for the area of interest   
- set up points within hexes, assign species to points  
- combine basemap, hex grid, points into single figure 

Let's begin by loading the R packages we'll be using. 

```{r}
#| output: FALSE
library(galah)
library(ozmaps)
library(sf)
library(tidyverse)
library(stringr)
```

We'll use the [{galah} package](https://galah.ala.org.au) to download occurrence records from the [Atlas of Living Australia (ALA)](https://www.ala.org.au). To do this, you'll need to [register your email address with the ALA](https://auth.ala.org.au/userdetails/registration/createAccount), then pass it to {galah} using `galah_config()`.

**CALLUM: would you prefer to use your work email address?**

```{r}
#| include: FALSE
galah_config(email = "callumwaite2000@gmail.com")
```

```{r}
#| eval: FALSE
galah_config(email = "your-email@email.com")
```

## Download data

Since our goal here is to map distributions of multiple species, we've chosen honeyeaters from the genus *Melithreptus*: this is a distinctive group of 7 small- to medium-sized, short-billed and square-tailed honeyeaters with overlapping distributions across Australia.

We can get taxonomic information about this group using `atlas_species()`...

```{r}
melithreptus <- galah_call() |>
  galah_identify("Melithreptus") |>
  atlas_species()

melithreptus
```

... and then use this information to download occurrence records for the 7 species. We'll apply the general data quality profile to filter out low quality records, pass in the list of species we're interested in with `galah_identify()`, filter records to 2022 [^1] that also have spatial coordinates, and fall within one of the [IBRA bioregions](https://www.dcceew.gov.au/environment/land/nrs/science/ibra) as a proxy for Australian records only.

[^1]: There are over half a million records from this genus in the ALA, so restricting our download to records from 2022 significantly speeds things up!

**DAX: not sure what the convention is here - do we store downloaded data as RDS files and load them instead of downloading each time? Also I can't remember where they get saved**

```{r}
#| eval: true
#| echo: false
species_occ <- readRDS(here::here("posts", "2023-11-14_hex_point_maps", "species_occ.RDS"))
```

```{r}
#| eval: false
#| echo: true
species_occ <- galah_call() |>
  galah_apply_profile(ALA) |>
  galah_identify(melithreptus$species) |>
  galah_filter(year == 2022,
               !is.na(cl1048),  # IBRA bioregions
               !is.na(decimalLatitude),
               !is.na(decimalLongitude)) |>
  galah_select(decimalLatitude,
               decimalLongitude,
               species, 
               vernacularName, 
               scientificName) |> 
  atlas_occurrences()

head(species_occ)
```

```{r}
#| echo: false
head(species_occ)
```

Since we're going to be performing a few spatial operations to get species in hexagons, we'll also convert the `species_occ` dataframe into a simple features object, with the latitude and longitude columns represented as points in a geometry column named `occ_geometry`.

```{r}
species_occ_sf <- species_occ |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), 
           crs = 4326) |> 
  st_set_geometry("occ_geometry")

```

## Generate hex grid 

Next, we'll set up a grid of hexagons across terrestrial Australia, which we'll use as bins for plotting summaries of species occurrence. `st_make_grid()` has arguments for specifying the size, type, and orientation of polygons in the grid, and this is initially created across the entire bounding box of the supplied shapefile (here the `ozmap_country` shapefile). We can then use a spatial filter to exclude any hexagons that do not intersect with the shapefile polygon boundary, and assign a unique identifier to each remaining hexagon.  

```{r}
hex_grid <- st_make_grid(ozmap_country,
                         cellsize = 2,
                         what = "polygons",
                         square = FALSE,
                         flat_topped = TRUE) |>  
  st_as_sf() |>   
  st_filter(ozmap_country) |> 
  st_set_geometry("hex_geometry") |> 
  st_transform(4326) |> 
  rowid_to_column(var = "hex_id")
```

Our grid of hexagons now looks like this:

```{r}
#| eval: true
#| echo: false
ggplot() +
  geom_sf(data = ozmap_states, 
          colour = "darkgrey", 
          fill = NA, 
          linewidth = 0.3) +
  geom_sf(data = hex_grid, 
          fill = NA, 
          col = "deepskyblue4", 
          linewidth = 0.4) +
  theme_void()
```

### Remove empty hexes

Not every hexagon will contain an occurrence record, though, so let's remove empty hexagons with a spatial join (which behaves similarly to `dplyr::left_join()` for spatial objects). This returns an object with the same number of rows as our original download of occurrence records, with additional columns containing information on which polygon each species occurs in. 

```{r}
hex_with_species <- st_join(x = hex_grid, 
                            y = species_occ_sf,
                            join = st_intersects,
                            left = FALSE)

head(hex_with_species, n = 10)
```

This means any hexagons we initially created in the grid that don't intersect with occurrence records have been removed:

```{r}
#| eval: true
#| echo: false
ggplot() +
  geom_sf(data = ozmap_states, 
          colour = "darkgrey", 
          fill = NA, 
          linewidth = 0.3) +
  geom_sf(data = count(hex_with_species, hex_id, hex_geometry), 
          fill = NA, 
          col = "deepskyblue4", 
          linewidth = 0.4) +
  theme_void()
```

### Set up positions

Since some hexagons will contain occurrence records for more than one species, we need a way to display these overlaps. We'll do this by setting up 7 positions in each hexagon, 1 for each species, and assign each species a position and colour so they can be visually differentiated. 

The figure below summarises how we'll do this: for each hexagon remaining in the grid, we'll generate a smaller hexagon, then get the coordinates of each vertex and centroid of the smaller hexagon. 

**Callum: My brain is not cooperating so I can't actually visualise this but I trust it's true**
<aside>It's worth noting that with a bit of creativity, it is possible to fit any number of points from 2-9 into a hexagon (2-7) or square symmetrically.</aside>

```{r}
#| eval: true
#| echo: false
#| column: screen

library(patchwork)

big_hex <- st_polygon(list(rbind(
  c(-1, 0),
  c(-0.5, sqrt(0.75)),
  c(0.5, sqrt(0.75)),
  c(1, 0),
  c(0.5,-sqrt(0.75)),
  c(-0.5,-sqrt(0.75)),
  c(-1, 0))))

small_hex <- st_buffer(big_hex, -0.3)

small_hex_vertices <- small_hex |>
  st_coordinates() |>
  as_tibble() |>
  st_as_sf(coords = c("X", "Y"), remove = FALSE) |> 
  rowid_to_column() |> 
  mutate(vertex_id = if_else(rowid %in% c(2:6), as.character(rowid), "1, 7"))

# 1. original hex
p1 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  labs(subtitle = "Original hex") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 2. smaller hex
p2 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex, fill = NA, linewidth = 1, colour = "deepskyblue3") +
  labs(subtitle = "Smaller hex") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 3. vertices
p3 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 3, colour = "deepskyblue3") +
  labs(subtitle = "Smaller hex vertices") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 4. vertex numbers
p4 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 3, colour = "deepskyblue3") +
  geom_text(data = small_hex_vertices, aes(X, Y, label = vertex_id), nudge_y = 0.12) +
  labs(subtitle = "Numbered vertices") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

# 5. with centroid
p5 <- ggplot() +
  geom_sf(data = big_hex, fill = NA, linewidth = 1.5, colour = "deepskyblue4") +
  geom_sf(data = small_hex_vertices, size = 3, colour = "deepskyblue3") +
  geom_sf(data = st_centroid(small_hex), size = 3, colour = "deepskyblue3") +
  geom_text(data = small_hex_vertices[c(1:6),], aes(X, Y, label = rowid), nudge_y = 0.12) +
  geom_sf_text(data = st_centroid(small_hex), aes(label = "7"), nudge_y = 0.12) +
  labs(subtitle = "Numbered vertices and centroid") +
  theme_void() +
  theme(plot.subtitle = element_text(hjust = 0.5))

p1 + p2 + p3 + p4 + p5 + plot_layout(ncol = 5)

```

Let's start by extracting the unique identifiers and spatial coordinates for every hexagon containing an occurrence record[^2]. 

[^2]: Using `distinct()` produces an identical result, but `count()` is much faster because checking for distinct values in the geometry column is computationally intensive. If your dataframe has fewer rows, you could also do this: `hex_with_species |> select(hex_id, hex_geometry) |> distinct()`.

**Callum/Dax: I was struggling to explain the unexpected choice of functions used here, and am not sure if the explanation actually clarifies anything**

```{r}
unique_hex <- hex_with_species |> 
  count(hex_id, hex_geometry) |> 
  select(-`n`)
```

We can then create a smaller hexagon within each original hexagon in the grid using `st_buffer()`, extract the coordinates of each vertex using `st_coordinates()`, and assign an integer to each vertex ranging from 1 to 7. Using `pmap()` here allows us to do this iteratively for every hexagon in the grid. 

<aside>Each hexagon is formed as a closed polygon, whereby the vertices are joined in the following order: 1-2-3-4-5-6-1. As a result, there are 7 rows of coordinates although there are only 6 vertices in each hexagon; the information in the first and seventh rows is duplicated.</aside>

Some points to note: the size of the smaller hexagon is set using the `dist` argument in `st_buffer()`, and this is in turn dependent on the `cellsize` of the original hexagon we created (in the example above, we set `cellsize` = 2). Depending on the number of species you'd like to fit within each polygon and the shape of the polygon you've chosen, you may need to try out different values of `cellsize` and `dist` to find combinations that work best for your visualisation. 

The resulting dataframe has a `geometry` column with spatial coordinates for each of the 7 vertices associated with the smaller hexagons we generated. 

```{r}
vertex_coords <- unique_hex |> 
  mutate(vertices = pmap(
    .l = list(x = hex_geometry),
    .f = function(x) {
      x |>
        st_buffer(dist = -0.3) |>
        st_coordinates() |>
        as_tibble() |>
        st_as_sf(coords = c("X", "Y")) |>
        select(-L1,-L2) |>
        mutate(vertex_position = 1:7)
    })) |> 
  unnest(cols = vertices)

head(vertex_coords, n = 10)
```

Since we need 7 positions in each hexagon (to fit a maximum of 7 species), and we conveniently have a duplicated row for every hexagon, we can mutate the repeated 7th vertex to hold the coordinates of the centroid of each hexagon. 

```{r}
vertex_centroid_coords <- vertex_coords |> 
  mutate(geometry = ifelse(vertex_position == 7,
                           st_centroid(hex_geometry),
                           geometry)) |> 
  st_drop_geometry() |> 
  st_as_sf(crs = 4326)
```

### Assign species to positions

All we have to do now is assign a position to each species... 
**Callum:I ended up keeping the horrible regex because it makes it easier to join in the next step- feel free to add more text to make this clearer or change the code if you can think of something better**

```{r}
species_data <- melithreptus |>
  select(species, vernacular_name) |>
  mutate(species = str_replace_all(species, "\\s*\\(.*?\\)\\s*", " "),
         vernacular_name = if_else(species == "Melithreptus chloropsis", 
                                   "Gilbert's Honeyeater",
                                   vernacular_name),
         position = c(1:7))
```

... and join that to the dataframe telling us which species occur in which hexagon. 

```{r}
species_points <- hex_with_species |>
  st_drop_geometry() |>
  select(hex_id, species) |>
  distinct() |> 
  left_join(species_data,
            by = join_by(species)) |>
  left_join(vertex_centroid_coords,
            by = join_by(position == vertex_position, hex_id == hex_id)) |> 
  st_as_sf(crs = 4326)
```

## Map

```{r}
# This is colour-blind safe so using it as a placeholder for now
# but it's not the nicest palette
okabe <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
ggplot() +
  geom_sf(data = ozmap_states, fill = NA, colour = "#ababab", linewidth = 0.3) +
  geom_sf(data = unique_hex, fill = "#efefef55", colour = "#777777", linewidth = 0.5) +
  geom_sf(data = species_points, aes(colour = species)) +
  scale_colour_manual(values = okabe) +
  lims(x = c(112, 155), y = c(-46, -8)) +
  theme_void()
```

<details>

<summary style="color: #E06E53;">

Expand for session info

</summary>

```{r, echo = FALSE}
library(sessioninfo)
# save the session info as an object
pkg_sesh <- session_info(pkgs = "attached")
# print it out
pkg_sesh
```

</details>
