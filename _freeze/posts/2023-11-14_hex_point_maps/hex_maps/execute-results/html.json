{
  "hash": "aa730f4a972b64f1f7a7ff75b50ba7ee",
  "result": {
    "markdown": "---\ntitle: \"Hex maps something something\"\ndescription: |\n  Visualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a method that allows users to get an overview of multiple species distributions in an area using a novel twist on the commonly used hexbin map.  \nauthor:\n  - name: \"Callum Waite\"\n  - name: \"Shandiya Balasubramaniam\"\ndate: \"2023-12-18\"\ntitle-block-banner: \"#B8573E\"\ninclude-after-body: _footer.html\ntoc: true\ntoc-location: left\ntoc-depth: 3\ncategories:\n  - Eukaryota\n  - Animalia\n  - Chordata\n  - Aves\n  - Summaries\n  - Maps\nimage: tbd\ndraft: true\nfreeze: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n<!-- remove metadata section -->\n\n\n```{=html}\n<style>\n  #title-block-header.quarto-title-block.default .quarto-title-meta {\n      display: none;\n  }\n</style>\n```\n\n<!-- Author card -->\n\n::: author-card\n::: author-card-text\n#### Author\n\n[Callum Waite](https://labs.ala.org.au/people/Waite_Callum/index.html)\\\n[Shandiya Balasubramaniam](https://labs.ala.org.au/people/Balasubramaniam_Shandiya/index.html)\n\n#### Date\n\n27 November 2023\n:::\n\n::: author-card-image\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/callum.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n::: author-card-image\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nVisualisations of species distributions can be very simple yet effective ways of conveying biological and ecological information, such as range, habitat, population size, fragmentation, and migration. This information can be represented as points, hulls, densities, and binned regions, to name but a few.\n\n**DAX: we could link to labs posts that show these methods?**\n\nRepresenting more than one species distribution in a single figure can be difficult, though, especially where there are areas of overlap. Points and hulls will obscure each other even with a degree of transparency, while densities and shaded regions can only show one species at a time. Comparisons can be made by providing two single distribution figures side-by-side, but it can be inconvenient to observe range overlaps in this manner.\n\nHere, we demonstrate a method to visualise distributions of multiple species with overlapping ranges on the same map, with only a small loss in resolution. The technique is a novel twist on the commonly used [hexbin map](https://r-graph-gallery.com/hexbin-map.html): instead of using a colour fill to represent presence/absence or counts within each hexagon, we use multiple coloured points within each hexagon to represent presence/absence of species, allowing users to get a broad overview of how multiple species are distributed across an area.\n\n**ADD A SECTION HERE EXPLAINING WHAT THE STEPS ARE GOING TO BE**\ne.g. We'll do this by: \n- download records for species of interest  \n- create a hex grid for the area of interest   \n- set up points within hexes, assign species to points  \n- combine basemap, hex grid, points into single figure \n\nLet's begin by loading the R packages we'll be using. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\nlibrary(ozmaps)\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(stringr)\n```\n:::\n\n\nWe'll use the [{galah} package](https://galah.ala.org.au) to download occurrence records from the [Atlas of Living Australia (ALA)](https://www.ala.org.au). To do this, you'll need to [register your email address with the ALA](https://auth.ala.org.au/userdetails/registration/createAccount), then pass it to {galah} using `galah_config()`.\n\n**CALLUM: would you prefer to use your work email address?**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalah_config(email = \"your-email@email.com\")\n```\n:::\n\n\n## Download data\n\nSince our goal here is to map distributions of multiple species, we've chosen honeyeaters from the genus *Melithreptus*: this is a distinctive group of 7 small- to medium-sized, short-billed and square-tailed honeyeaters with overlapping distributions across Australia.\n\nWe can get taxonomic information about this group using `atlas_species()`...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelithreptus <- galah_call() |>\n  galah_identify(\"Melithreptus\") |>\n  atlas_species()\n\nmelithreptus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 10\n  kingdom  phylum   class order         family genus species author species_guid\n  <chr>    <chr>    <chr> <chr>         <chr>  <chr> <chr>   <chr>  <chr>       \n1 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Viei… https://bio…\n2 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Vigo… https://bio…\n3 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… Gould… https://bio…\n4 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Goul… https://bio…\n5 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Less… https://bio…\n6 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Goul… https://bio…\n7 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… Gould… https://bio…\n# ℹ 1 more variable: vernacular_name <chr>\n```\n:::\n:::\n\n\n... and then use this information to download occurrence records for the 7 species. We'll apply the general data quality profile to filter out low quality records, pass in the list of species we're interested in with `galah_identify()`, filter records to 2022 [^1] that also have spatial coordinates, and fall within one of the [IBRA bioregions](https://www.dcceew.gov.au/environment/land/nrs/science/ibra) as a proxy for Australian records only.\n\n[^1]: There are over half a million records from this genus in the ALA, so restricting our download to records from 2022 significantly speeds things up!\n\n**DAX: not sure what the convention is here - do we store downloaded data as RDS files and load them instead of downloading each time? Also I can't remember where they get saved**\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_occ <- galah_call() |>\n  galah_apply_profile(ALA) |>\n  galah_identify(melithreptus$species) |>\n  galah_filter(year == 2022,\n               !is.na(cl1048),  # IBRA bioregions\n               !is.na(decimalLatitude),\n               !is.na(decimalLongitude)) |>\n  galah_select(decimalLatitude,\n               decimalLongitude,\n               species, \n               vernacularName, \n               scientificName) |> \n  atlas_occurrences()\n\nhead(species_occ)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  decimalLatitude decimalLongitude species         vernacularName scientificName\n            <dbl>            <dbl> <chr>           <chr>          <chr>         \n1           -43.6             147. Melithreptus v… Strong-billed… Melithreptus …\n2           -43.6             147. Melithreptus v… Strong-billed… Melithreptus …\n3           -43.5             146. Melithreptus v… Strong-billed… Melithreptus …\n4           -43.5             147. Melithreptus a… Black-headed … Melithreptus …\n5           -43.5             147. Melithreptus a… Black-headed … Melithreptus …\n6           -43.5             147. Melithreptus v… Strong-billed… Melithreptus …\n```\n:::\n:::\n\n\nSince we're going to be performing a few spatial operations to get species in hexagons, we'll also convert the `species_occ` dataframe into a simple features object, with the latitude and longitude columns represented as points in a geometry column named `occ_geometry`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_occ_sf <- species_occ |>\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) |> \n  st_set_geometry(\"occ_geometry\")\n```\n:::\n\n\n## Generate hex grid \n\nNext, we'll set up a grid of hexagons across terrestrial Australia, which we'll use as bins for plotting summaries of species occurrence. `st_make_grid()` has arguments for specifying the size, type, and orientation of polygons in the grid, and this is initially created across the entire bounding box of the supplied shapefile (here the `ozmap_country` shapefile). We can then use a spatial filter to exclude any hexagons that do not intersect with the shapefile polygon boundary, and assign a unique identifier to each remaining hexagon.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_grid <- st_make_grid(ozmap_country,\n                         cellsize = 2,\n                         what = \"polygons\",\n                         square = FALSE,\n                         flat_topped = TRUE) |>  \n  st_as_sf() |>   \n  st_filter(ozmap_country) |> \n  st_set_geometry(\"hex_geometry\") |> \n  st_transform(4326) |> \n  rowid_to_column(var = \"hex_id\")\n```\n:::\n\n\nOur grid of hexagons now looks like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](hex_maps_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n### Remove empty hexes\n\nNot every hexagon will contain an occurrence record, though, so let's remove empty hexagons with a spatial join (which behaves similarly to `dplyr::left_join()` for spatial objects). This returns an object with the same number of rows as our original download of occurrence records, with additional columns containing information on which polygon each species occurs in. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_with_species <- st_join(x = hex_grid, \n                            y = species_occ_sf,\n                            join = st_intersects,\n                            left = FALSE)\n\nhead(hex_with_species, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 10 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 145.9652 ymin: -44.63203 xmax: 148.2746 ymax: -42.63203\nGeodetic CRS:  WGS 84\n    hex_id                    species           vernacularName\n1        1 Melithreptus validirostris Strong-billed Honeyeater\n1.1      1 Melithreptus validirostris Strong-billed Honeyeater\n1.2      1 Melithreptus validirostris Strong-billed Honeyeater\n1.3      1       Melithreptus affinis  Black-headed Honeyeater\n1.4      1       Melithreptus affinis  Black-headed Honeyeater\n1.5      1 Melithreptus validirostris Strong-billed Honeyeater\n1.6      1 Melithreptus validirostris Strong-billed Honeyeater\n1.7      1 Melithreptus validirostris Strong-billed Honeyeater\n1.8      1 Melithreptus validirostris Strong-billed Honeyeater\n1.9      1 Melithreptus validirostris Strong-billed Honeyeater\n                             scientificName                   hex_geometry\n1   Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.1 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.2 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.3     Melithreptus (Melithreptus) affinis POLYGON ((145.9652 -43.6320...\n1.4     Melithreptus (Melithreptus) affinis POLYGON ((145.9652 -43.6320...\n1.5 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.6 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.7 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.8 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n1.9 Melithreptus (Eidopsarus) validirostris POLYGON ((145.9652 -43.6320...\n```\n:::\n:::\n\n\nThis means any hexagons we initially created in the grid that don't intersect with occurrence records have been removed:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](hex_maps_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### Set up positions\n\nSince some hexagons will contain occurrence records for more than one species, we need a way to display these overlaps. We'll do this by setting up 7 positions in each hexagon, 1 for each species, and assign each species a position and colour so they can be visually differentiated. \n\nThe figure below summarises how we'll do this: for each hexagon remaining in the grid, we'll generate a smaller hexagon, then get the coordinates of each vertex and centroid of the smaller hexagon. \n\n**Callum: My brain is not cooperating so I can't actually visualise this but I trust it's true**\n<aside>It's worth noting that with a bit of creativity, it is possible to fit any number of points from 2-9 into a hexagon (2-7) or square symmetrically.</aside>\n\n\n::: {.cell .column-screen}\n::: {.cell-output-display}\n![](hex_maps_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nLet's start by extracting the unique identifiers and spatial coordinates for every hexagon containing an occurrence record[^2]. \n\n[^2]: Using `distinct()` produces an identical result, but `count()` is much faster because checking for distinct values in the geometry column is computationally intensive. If your dataframe has fewer rows, you could also do this: `hex_with_species |> select(hex_id, hex_geometry) |> distinct()`.\n\n**Callum/Dax: I was struggling to explain the unexpected choice of functions used here, and am not sure if the explanation actually clarifies anything**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_hex <- hex_with_species |> \n  count(hex_id, hex_geometry) |> \n  select(-`n`)\n```\n:::\n\n\nWe can then create a smaller hexagon within each original hexagon in the grid using `st_buffer()`, extract the coordinates of each vertex using `st_coordinates()`, and assign an integer to each vertex ranging from 1 to 7. Using `pmap()` here allows us to do this iteratively for every hexagon in the grid. \n\nSome points to note: the size of the smaller hexagon is set using the `dist` argument in `st_buffer()`, and this is in turn dependent on the `cellsize` of the original hexagon we created (in the example above, we set `cellsize` = 2). Depending on the number of species you'd like to fit within each polygon and the shape of the polygon you've chosen, you may need to try out different values of `cellsize` and `dist` to find combinations that work best for your visualisation. \n\nThe resulting dataframe has a `geometry` column with spatial coordinates for each of the 7 vertices associated with the smaller hexagons we generated. \n\n<aside>Each hexagon is formed as a closed polygon, whereby the vertices are joined in the following order: 1-2-3-4-5-6-1. As a result, there are 7 rows of coordinates although there are only 6 vertices in each hexagon; the information in the first and seventh rows is duplicated.</aside>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_coords <- unique_hex |> \n  mutate(vertices = pmap(\n    .l = list(x = hex_geometry),\n    .f = function(x) {\n      x |>\n        st_buffer(dist = -0.3) |>\n        st_coordinates() |>\n        as_tibble() |>\n        st_as_sf(coords = c(\"X\", \"Y\")) |>\n        select(-L1,-L2) |>\n        mutate(vertex_position = 1:7)\n    })) |> \n  unnest(cols = vertices)\n\nhead(vertex_coords, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 10 features and 2 fields\nActive geometry column: hex_geometry\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 144.2331 ymin: -44.63203 xmax: 148.2746 ymax: -41.63203\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 4\n   hex_id                 hex_geometry             geometry vertex_position\n    <int>                <POLYGON [°]>              <POINT>           <int>\n 1      1 ((145.9652 -43.63203, 146.5… (146.3116 -43.63203)               1\n 2      1 ((145.9652 -43.63203, 146.5… (146.7157 -42.93203)               2\n 3      1 ((145.9652 -43.63203, 146.5…  (147.524 -42.93203)               3\n 4      1 ((145.9652 -43.63203, 146.5… (147.9282 -43.63203)               4\n 5      1 ((145.9652 -43.63203, 146.5…  (147.524 -44.33203)               5\n 6      1 ((145.9652 -43.63203, 146.5… (146.7157 -44.33203)               6\n 7      1 ((145.9652 -43.63203, 146.5… (146.3116 -43.63203)               7\n 8      2 ((144.2331 -42.63203, 144.8… (144.5795 -42.63203)               1\n 9      2 ((144.2331 -42.63203, 144.8… (144.9837 -41.93203)               2\n10      2 ((144.2331 -42.63203, 144.8…  (145.792 -41.93203)               3\n```\n:::\n:::\n\n\nSince we need 7 positions in each hexagon (to fit a maximum of 7 species), and we conveniently have a duplicated row for every hexagon, we can mutate the repeated 7th vertex to hold the coordinates of the centroid of each hexagon. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_centroid_coords <- vertex_coords |> \n  mutate(geometry = ifelse(vertex_position == 7,\n                           st_centroid(hex_geometry),\n                           geometry)) |> \n  st_drop_geometry() |> \n  st_as_sf(crs = 4326)\n```\n:::\n\n\n### Assign species to positions\n\nAll we have to do now is assign a position to each species... \n**Callum:I ended up keeping the horrible regex because it makes it easier to join in the next step- feel free to add more text to make this clearer or change the code if you can think of something better**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_data <- melithreptus |>\n  select(species, vernacular_name) |>\n  mutate(species = str_replace_all(species, \"\\\\s*\\\\(.*?\\\\)\\\\s*\", \" \"),\n         vernacular_name = if_else(species == \"Melithreptus chloropsis\", \n                                   \"Gilbert's Honeyeater\",\n                                   vernacular_name),\n         position = c(1:7))\n```\n:::\n\n\n... and join that to the dataframe telling us which species occur in which hexagon. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_points <- hex_with_species |>\n  st_drop_geometry() |>\n  select(hex_id, species) |>\n  distinct() |> \n  left_join(species_data,\n            by = join_by(species)) |>\n  left_join(vertex_centroid_coords,\n            by = join_by(position == vertex_position, hex_id == hex_id)) |> \n  st_as_sf(crs = 4326)\n```\n:::\n\n\n## Map\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is colour-blind safe so using it as a placeholder for now\n# but it's not the nicest palette\nokabe <- c(\"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")\nggplot() +\n  geom_sf(data = ozmap_states, fill = NA, colour = \"#ababab\", linewidth = 0.3) +\n  geom_sf(data = unique_hex, fill = \"#efefef55\", colour = \"#777777\", linewidth = 0.5) +\n  geom_sf(data = species_points, aes(colour = species)) +\n  scale_colour_manual(values = okabe) +\n  lims(x = c(112, 155), y = c(-46, -8)) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](hex_maps_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n<details>\n\n<summary style=\"color: #E06E53;\">\n\nExpand for session info\n\n</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1.2\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Australia/Melbourne\n date     2023-12-18\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)\n galah       * 2.0.0   2023-11-20 [1] CRAN (R 4.3.1)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.1)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.1)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.0)\n patchwork   * 1.1.3   2023-08-14 [1] CRAN (R 4.3.0)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "hex_maps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}