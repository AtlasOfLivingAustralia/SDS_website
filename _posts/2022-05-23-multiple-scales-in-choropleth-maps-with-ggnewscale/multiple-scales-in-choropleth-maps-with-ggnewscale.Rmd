---
title: "Multiple scales in choropleth maps with {ggnewscale}"
description: |
  Wherein we download records of plants from the ALA and scale the dizzy heights of adding multiple colour scales to differentiate marine and terrestrial records    
author:
  - name: "Shandiya Balasubramaniam"
date: '2022-05-23'
categories: 
  - Plantae
  - Chlorophyta
  - Maps
output: 
  distill::distill_article:
    highlight: tango
    toc: true
    toc_float: true
    toc_depth: 3  
draft: true      
---

<!------ Complete title, description, author and date for website metadata ------>

<!-- load html package & get date -->

```{r, include=FALSE}
library(htmltools)
date.func <- format(Sys.time(), '%d %B, %Y')
```

<!-- remove distill metadata section -->

```{css, echo = FALSE}
d-byline {
    display: none;
  }
```

<!-- Author card -->

::: author-card
::: float-image

<!-- Author image -->

```{r, out.width='120px', out.extra='style="float:right; margin-left:15px; margin-right:50px; clip-path: circle();"', echo=FALSE}
# add author first name at the end of this url (e.g., ".../people/martin.jpg")
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.jpg")
```

::: author-card-text
<!-- Author name -->

<h4 style="margin-bottom:5px">

Author:

</h4>

[Shandiya Balasubramaniam](https://labs.ala.org.au/people/Balasubramaniam_Shandiya/index.html)

<!-- Date -->

<h4 style="margin-bottom:5px">

Date:

</h4>

23 May, 2022
:::
:::
:::

<br>

<!------ Post content starts here ------>

> “I found I could say things with color and shapes that I couldn't say any other way”  
> - Georgia O'Keeffe  

Choropleth maps visually represent how aggregated summaries of a variable (e.g. density of lamp posts, per capita books read) vary across geographic areas. These maps require two inputs: a geospatial object with information on regional boundaries, and a numerical variable that can be mapped to each geographic unit using colour. Here, I walk through the process of mapping the density of plant records from the ALA to geographic bioregions across Australia, using two colour scales to differentiate between marine and terrestrial records. 

# Part 1: Where we intrepidly get data

Let's start by loading the packages we'll need. 

```{r packages, message = FALSE, warning = FALSE}

library(galah)
library(here)
library(sf)
library(rmapshaper)
library(dplyr)
library(stringr)
library(ggplot2)
library(showtext)
library(ggnewscale)

```

Next up, we'll need some regional boundaries. I think the [IBRA7](https://data.gov.au/dataset/ds-dga-d44dd392-ebea-4f1a-b30e-4a2da154aae4/details?q=ibra) and [IMCRA4](https://data.gov.au/dataset/ds-dga-3245ad6c-cc00-4404-ba1f-476c07b5f762/details?q=imcra) bioregions will work nicely for what we're planning. These boundaries classify Australia's landscapes and waters into geographically distinct bioregions based on variables like climate, geomorphology, and species information. After downloading the data, we can read it in using the `sf` package and check that it looks correct. Here, I've also elected to use `ms_simplify()` from the `rmapshaper` package to simplify the geospatial features and speed up computation.    

```{r shapefiles, message = FALSE, warning = FALSE, fig.show = "hold", out.width = "50%"}

# read in IMCRA shapefile
imcra_shp <- st_read(here("_posts", 
                          "data",
                          "imcra_mesoscale_bioregions",
                          "imcra4_meso.shp"), 
                     quiet = TRUE) |> 
  ms_simplify(keep = 0.1)

plot(imcra_shp$geometry)

# read in IBRA shapefile
ibra_shp <- st_read(here("_posts",
                         "data",
                         "IBRA7_regions",
                         "ibra7_regions.shp"),
                    quiet = TRUE) |> 
  ms_simplify(keep = 0.1)

plot(ibra_shp$geometry)

```

And finally, let's get the number of plant records in the ALA using the `galah` package, grouped by IBRA or IMCRA region. To do this, we need to know what the ALA calls the IBRA and IMCRA layers. We'll get this information using the `search_fields()` function.  

```{r fields, echo = TRUE, message = FALSE, warning = FALSE}

galah::search_fields("IBRA")
galah::search_fields("IMCRA")

```

Great! Now that we know the IBRA layer we're after is called **cl1048** and the IMCRA layer, **cl966**, we can pass a query with `galah_call()`, which lets us structure the query using pipes. We can specify that we only want plant records matching *Plantae* or *Chlorophyta* using `galah_identify()`, apply the default set of ALA data quality filters to remove poor quality records using `galah_filter()`, group records by region using `galah_group_by()`, and finally return the counts of records that match all our criteria with `atlas_counts()`.    

```{r counts, echo = TRUE, message = FALSE, warning = FALSE}

# counts in IBRA regions
ibra_counts <- galah_call() |>
  galah_identify("plantae", "chlorophyta") |>
  galah_filter(profile = "ALA") |> 
  galah_group_by("cl1048") |>      # IBRA regions
  atlas_counts()

head(ibra_counts)

# counts in IMCRA regions
imcra_counts <- galah_call() |>
  galah_identify("plantae", "chlorophyta") |>
  galah_filter(profile = "ALA") |> 
  galah_group_by("cl966") |>      # IMCRA bioregions
  atlas_counts()

head(imcra_counts)

```

# Part 2: Where we fearlessly tidy, transform, and join

We've now got the two inputs we need to make a choropleth: IBRA/IMCRA boundaries, and counts of plant records in each region. To create a plot, we need to combine the geospatial and numeric data. But first, a little light tidying.  

Since we're going to be joining the spatial and count data, we need to be sure that the names of the IBRA/IMCRA regions match in both datasets. We check this thusly.

```{r check-names, echo = TRUE, message = FALSE, warning = FALSE}

# check region names match
setdiff(ibra_counts$cl1048, ibra_shp$REG_NAME_7)
setdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)

```

Hmm... Looks like the IBRA region names match in both datasets, but not the IMCRA. Let's dig a bit further.

```{r check-names-imcra, echo = TRUE, message = FALSE, warning = FALSE}

# check the reverse for IMCRA names
setdiff(imcra_shp$MESO_NAME, imcra_counts$cl966)

```

Ok, so Pilbara is incorrectly spelled in the `imcra_counts` dataset. With a little light wrangling, we can rectify this. 

```{r rename-imcra, echo = TRUE, message = FALSE, warning = FALSE}

# replace "Pilbarra" with "Pilbara" 
imcra_counts <- imcra_counts |> 
  mutate(cl966 = str_replace(string = cl966, 
                             pattern = "Pilbarra", 
                             replacement = "Pilbara"))

# check names match
setdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)

```

Well this is gratifying, now both sets of names match. Onward with our tidying!  

Let's also check the distribution of counts in each dataset. 

```{r hist, message = FALSE, warning = FALSE, fig.show = "hold", out.width = "50%"}

hist(imcra_counts$count)
hist(ibra_counts$count)

```

That's a substantial skew to the right; let's try a log-transformation.

```{r log-hist, message = FALSE, warning = FALSE, fig.show = "hold", out.width = "50%"}

hist(log(imcra_counts$count))
hist(log(ibra_counts$count))

```
 
Much better. Let's get joining!

Here, we join the geospatial and numeric data. Along the way, we rename some columns, remove unnecessary columns, calculate counts as a proportion of the area of each region (so we're plotting density of records, not counts of records), and convert the resulting dataframe into a simple features object. 

```{r join, message = FALSE, warning = FALSE}

imcra_join <- imcra_counts |> 
  full_join(y = imcra_shp, by = c("cl966" = "MESO_NAME")) |> 
  rename("imcra" = "cl966") |> 
  select(imcra, count, AREA_KM2, geometry) |> 
  mutate(density_log10 = log10(count / AREA_KM2)) |> 
  select(imcra, density_log10, geometry) |> 
  st_as_sf()

ibra_join <- ibra_counts |> 
  full_join(y = ibra_shp, by = c("cl1048" = "REG_NAME_7")) |> 
  rename("ibra" = "cl1048") |> 
  select(ibra, count, SQ_KM, geometry) |> 
  mutate(density_log10 = log10(count / SQ_KM)) |> 
  select(ibra, density_log10, geometry) |> 
  st_as_sf()

```


# Part 3: Where we map with gay abandon   

Finally, the reason we're all here. Let's get mapping! We'll use the `ggnewscale` package to apply different colour palettes to the marine and terrestrial data. 

```{r plot, echo = TRUE, message = FALSE, warning = FALSE}

# add some custom fonts
font_add_google("Lato", "lato")
showtext_auto()

# map
ggplot() + 
  geom_sf(data = imcra_join,
          aes(fill = density_log10),
          colour = NA) +
  scale_fill_distiller(name = "IMCRA",
                       type = "seq",
                       palette = "BuPu",
                       direction = 1,
                       labels = c("0.001", "0.01", "0.1", "1", "10"),
                       guide = guide_colorsteps(direction = "horizontal",
                                                label.position = "bottom",
                                                title.position = "left",
                                                title.hjust = 0.8,
                                                title.vjust = 0.8)) +
  new_scale_fill() +
  geom_sf(data = ibra_join,
          aes(fill = density_log10),
          colour = NA) +
  scale_fill_distiller(name = "IBRA",
                       type = "seq",
                       palette = "YlOrBr",
                       direction = 1,
                       labels = c("0.1", "1", "10", "100"),
                       guide = guide_colorsteps(direction = "horizontal",
                                                label.position = "bottom",
                                                title.position = "left",
                                                title.hjust = 0.8,
                                                title.vjust = 0.8)) +  
  annotate("text", 
           x = 133, 
           y = -45.5, 
           label = "No. of records per square km",
           size = 6) +
  coord_sf(xlim = c(110, 155), ylim = c(-45, -10)) +
  theme_void() +
  theme(text = element_text(family = "lato"),
        title = element_text(face = "bold"),
        legend.position = "bottom",
        legend.key.width = unit(12, 'mm'),
        plot.background = element_rect(fill = 'white', colour = 'white'),
        panel.background = element_rect(fill = 'white', colour = 'white'))

```

Success!  

One thing to note is that we didn't necessarily have to use `ggnewscale` here; we could just as easily have combined all the data and plotted them on the same map without keeping the IBRA and IMCRA datasets separate. But, i) it's nice to be able to differentiate marine and terrestrial regions at a glance, and ii) using two legends also makes it clear that there's a stark difference in the number of plant records for marine and terrestrial regions.   

Happy plotting, everyone.

