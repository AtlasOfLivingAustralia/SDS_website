[
  {
    "path": "posts/2021-04-14_hex-maps-for-species-occurrence-data/",
    "title": "Hex maps for species occurrence data",
    "description": "Hex maps are a neat way to represent spatial information. Here, we \nshow how to draw one using the most common species in the ALA database: \nthe iconic Australian Magpie.",
    "author": [
      {
        "name": "Matilda Stevenson",
        "url": {}
      }
    ],
    "date": "2022-02-25",
    "categories": [
      "Maps",
      "Eukaryota",
      "Animalia",
      "Chordata",
      "Aves"
    ],
    "contents": "\r\n\r\nContents\r\nGetting species occurrences\r\nPlotting binned data\r\n\r\n\r\n\r\n\r\n/* Remove distill metadata section */\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMatilda Stevenson, Martin Westgate, Dax Kellie\r\n\r\n\r\nDate:\r\n\r\n25 February, 2022\r\n\r\n\r\n\r\n\r\n\r\nThe Atlas of Living Australia (ALA) holds records of magpie sightings from a number data providers like iNaturalist, eBird and BirdLife Australia. Let’s make a visualisation of Australian Bird of the Year 2018 winner, Magpies, using records held in the ALA.\r\nGetting species occurrences\r\nAs with any R project, a good first step is to load the required packages\r\n\r\n\r\n# packages\r\nlibrary(ggplot2)\r\nlibrary(tidyr)\r\nlibrary(dplyr)\r\nlibrary(ozmaps)\r\nlibrary(sf)\r\nlibrary(hexbin)\r\n\r\n\r\n\r\nWe will use the {galah} package to download records.\r\nTo download species occurrence records, the {galah} package requires you to add an email registered with the ALA to galah_config(). If running this code yourself, you will need to add an email using the code below, substituting your email with myemail@email.com. This email address should be registered with the ALA, which you can do here\r\n\r\n\r\nlibrary(galah)\r\ngalah_config(email = \"myemail@email.com\")\r\n\r\n\r\n\r\nNow we can download magpie occurrence records by using atlas_occurrences(). Note that we also set our data ‘profile’ to ‘ALA’; this means we only download records that meet some basic data quality standards enforced by the atlas. This is optional, but tends to improve the quality of the data returned. (If you wish to see the data quality filters applied in the ALA profile, use search_profile_attributes(\"ALA\"))\r\n\r\n\r\nmagpie_occ <- galah_call() %>%\r\n  galah_identify(\"Cracticus tibicen\") %>%\r\n  galah_filter(profile = \"ALA\") %>%\r\n  atlas_occurrences()\r\n\r\n\r\n\r\nLet’s have a look at the first few rows of the data we’ve just downloaded:\r\n\r\n\r\nmagpie_occ %>% head()\r\n\r\n\r\n# A tibble: 6 x 7\r\n  decimalLatitude decimalLongitude eventDate            scientificName\r\n            <dbl>            <dbl> <chr>                <chr>         \r\n1           -45.0             169. \"\"                   Gymnorhina ti~\r\n2           -44.5             170. \"2018-10-27T21:44:0~ Gymnorhina ti~\r\n3           -44.1             170. \"2019-05-02T05:18:0~ Gymnorhina ti~\r\n4           -43.6             147. \"\"                   Gymnorhina ti~\r\n5           -43.6             147. \"\"                   Gymnorhina ti~\r\n6           -43.6             147. \"\"                   Gymnorhina ti~\r\n# ... with 3 more variables: taxonConceptID <chr>, recordID <chr>,\r\n#   dataResourceName <chr>\r\n\r\nFor the purpose of this exercise, we’re going to filter records not on the mainland or Tasmania.\r\n\r\n\r\nfiltered_occ <- magpie_occ %>% filter(decimalLongitude < 155,\r\n                                      decimalLongitude > 110,\r\n                                      decimalLatitude > -45,\r\n                                      decimalLatitude < -10)\r\n\r\n\r\n\r\nPlotting binned data\r\nThe easiest way to create a hex map is using the hexbin package\r\n\r\n\r\nggplot(filtered_occ) +\r\n  geom_hex(mapping = aes(x = decimalLongitude, y = decimalLatitude), \r\n           bins = 47, \r\n           colour = \"white\") +\r\n  ylim(-45, -10) +\r\n  xlim(110, 155) +\r\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\")) +\r\n  coord_fixed() +\r\n  theme_bw() +\r\n  theme(\r\n    panel.border = element_blank(),\r\n    panel.grid.major = element_blank(),\r\n    panel.grid.minor = element_blank(),\r\n    axis.text = element_blank(),\r\n    axis.ticks = element_blank(),\r\n    axis.title = element_blank(),\r\n    legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nWhile automated methods are nice, it might sometimes be useful to create our hexagons manually. We can do this by manually creating hexagons, linking them to a grid of Australia, and adding our data of magpie counts to set the fill color of those hexagons. To achieve this, we first convert the map of Australia provided by ozmaps to the same coordinate system as ALA data:\r\n\r\n\r\naus <- st_transform(ozmaps::ozmap_country, 4326)\r\n\r\n\r\n\r\nWe then transform points from our data frame of magpie occurrences to the correct coordinates\r\n\r\n\r\npoints <- lapply(1:nrow(filtered_occ), function(x) {\r\n  st_point(c(as.numeric(filtered_occ[x,'decimalLongitude']),\r\n                        as.numeric(filtered_occ[x,'decimalLatitude'])))\r\n})\r\n\r\n\r\n\r\nNow build the hexagonal grid\r\n\r\n\r\ngrid_all <- st_make_grid(aus, cellsize = 1, what = \"polygons\", square = FALSE)[aus]\r\ngridSF <- st_as_sf(grid_all)\r\n\r\n# Find which polygon each point is in\r\nintersect <- st_intersects(st_as_sfc(points) %>% st_set_crs(4326), gridSF)\r\n\r\n# count the number of points in each hexagon\r\nfreqs <- as.data.frame(table(unlist(intersect)), stringsAsFactors = FALSE)\r\n\r\nnames(freqs) <- c(\"hex_id\", \"count\")\r\n\r\n\r\n\r\nAdd our magpie counts data to the hexagons and fill hexagons without data\r\n\r\n\r\nfreqs$hex_id <- as.integer(freqs$hex_id)\r\n\r\n# fill in the values for hexagons with no records\r\nfilled_freqs <- freqs %>%\r\n  complete(hex_id = full_seq(c(1,925), 1), fill = list(count = 0))\r\ngridSF$n <- filled_freqs$count\r\n\r\n\r\n\r\nFinally, build the plot\r\n\r\n\r\nggplot() +\r\n  geom_sf(data = gridSF, aes(fill = n), size = .01) +\r\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\"), na.value = \"white\", trans = \"log2\") +\r\n  ylim(-45, -10) +\r\n  xlim(110, 155) +\r\n  theme_bw() +\r\n  theme(\r\n    panel.border = element_blank(),\r\n    panel.grid.major = element_blank(),\r\n    panel.grid.minor = element_blank(),\r\n    axis.text = element_blank(),\r\n    axis.ticks = element_blank(),\r\n    axis.title = element_blank(),\r\n    legend.position = \"none\") \r\n\r\n\r\n\r\n\r\nThat’s it! All the extra work does make a difference in this case, providing a better representation of the spread of Mapgies across Australia. Manually constructing hex maps can be useful in other circumstances, too. For example, if we wanted to compare the number of magpies to contextual information within each polygon (such as rainfall or human population data), then manually constructing our own hexagons could help us to combine data from different sources.\r\nA final point is that we could have achieved the same result by creating polygons first, then querying the ALA for the number of magpie records in each polygon using galah_geolocate(). That’s a bit more challenging, and not worthwhile in this case; but it can be an efficient solution where you require information on more species than there are polygons, for example. We’ll come back to this point in a future blog post.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-04-14_hex-maps-for-species-occurrence-data/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/",
    "title": "Sunburst plots for taxonomic data",
    "description": "Since version 1.3.1 of `galah`, it has been possible to download taxonomic\ndata using a 'tree' format from the `data.tree` package. Here I'll demonstrate\nsome ideas for plotting these trees using circular diagrams.",
    "author": [
      {
        "name": "Martin Westgate",
        "url": {}
      }
    ],
    "date": "2022-02-17",
    "categories": [
      "Trees",
      "Eukaryota",
      "Animalia",
      "Chordata"
    ],
    "contents": "\r\n\r\nContents\r\nDownloading taxonomic trees\r\nGetting plot-ready data\r\nDrawing\r\n\r\n\r\n\r\n\r\n\r\n\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMartin Westgate\r\n\r\n\r\nDate:\r\n\r\n17 February, 2022\r\n\r\n\r\n\r\n\r\n\r\nTaxonomy is pretty important at the ALA. Every occurrence record in the atlas is linked to a unique taxonomic identifier. These identifiers are themselves drawn from expertly curated taxonomic datasets. This system of classification is so important to our infrastructure that we have a special name for it; the ‘taxonomic backbone’. But what does it look like?\r\nVisualising trees is not particularly easy for me; I didn’t train in it, and the data structures involved can be a bit complex. More importantly, until recently it was difficult to download detailed taxonomic information from the ALA. Since version 1.3.1 of galah, however, it has been possible to download taxonomic trees using the atlas_taxonomy() function. Let’s have a go at visualising these trees now.\r\nDownloading taxonomic trees\r\nThe first step is to choose a taxonomic group to represent in tree form. I’ve chosen the chordates (Phylum Chordata) because they aren’t too large a group and the names are fairly well-known. We can specify this within galah using the function galah_identify. The second piece of information we need to supply is how far ‘down’ the tree to travel. I’ve chosen the Order level here using galah_down_to(order); while we could have gone to the Family or even Genus, trying to traverse too many levels (i.e. to Genus or Species) would take a very long time. A full list of accepted ranks can be found by calling show_all_ranks().\r\n\r\n\r\nlibrary(galah)\r\nchordate_orders <- galah_call() |>\r\n  galah_identify(\"chordata\") |>\r\n  galah_down_to(order) |>\r\n  atlas_taxonomy()\r\n\r\n\r\n\r\nThe object returned by atlas_taxonomy is slightly unusual; it uses the data.tree package, meaning that the dataset is literally structured like a tree. This is notably different from other representations of networks, such as you might find in igraph, for example. To get an idea of what the data look like, we can use the inbuilt print method for this data type:\r\n\r\n\r\nlibrary(data.tree)\r\nprint(chordate_orders, pruneMethod = \"dist\", limit = 10)\r\n\r\n\r\n                            levelName\r\n1  Chordata                          \r\n2   ¦--Cephalochordata               \r\n3   ¦   °--Amphioxi                  \r\n4   ¦       °--... 1 nodes w/ 0 sub  \r\n5   ¦--Tunicata                      \r\n6   ¦   ¦--Appendicularia            \r\n7   ¦   ¦   °--... 1 nodes w/ 0 sub  \r\n8   ¦   ¦--Ascidiacea                \r\n9   ¦   ¦   °--... 5 nodes w/ 0 sub  \r\n10  ¦   °--Thaliacea                 \r\n11  ¦       °--... 3 nodes w/ 0 sub  \r\n12  °--Vertebrata                    \r\n13      ¦--Agnatha                   \r\n14      ¦   °--... 2 nodes w/ 2 sub  \r\n15      °--Gnathostomata             \r\n16          °--... 5 nodes w/ 134 sub\r\n\r\nThis shows there are three nodes directly beneath Chordata in the taxonomic hierarchy, of which the largest (by number of sub-nodes) is the vertebrates (Vertebrata). There is a lot we could do with this tree; each node contains a unique taxonomic identifer, for example, meaning that we could use individual nodes to make new queries using galah. However, for now a useful task is simply to visualise the structure of the whole tree.\r\nGetting plot-ready data\r\nTaxonomic trees are complex. While all species have a Kingdom, Phylum, Order, Class and Family, there are many intermediate categories that are ‘optional’. In practice, this means that when we convert to a data.frame for plotting, there are a lot of missing values; nodes that apply to some rows but not others.\r\n\r\n\r\ndf_rank <- ToDataFrameTypeCol(chordate_orders, type = \"rank\")\r\ndf_rank[10:20,]\r\n\r\n\r\n   rank_phylum rank_subphylum rank_class           rank_informal\r\n10    Chordata       Tunicata  Thaliacea                    <NA>\r\n11    Chordata     Vertebrata       <NA>         Myxini, Agnatha\r\n12    Chordata     Vertebrata       <NA> Petromyzontida, Agnatha\r\n13    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n14    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n15    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n16    Chordata     Vertebrata       Aves           Gnathostomata\r\n17    Chordata     Vertebrata       Aves           Gnathostomata\r\n18    Chordata     Vertebrata       Aves           Gnathostomata\r\n19    Chordata     Vertebrata       Aves           Gnathostomata\r\n20    Chordata     Vertebrata       Aves           Gnathostomata\r\n   rank_subclass rank_superorder rank_subinfraclass rank_infraclass\r\n10          <NA>            <NA>               <NA>            <NA>\r\n11          <NA>            <NA>               <NA>            <NA>\r\n12          <NA>            <NA>               <NA>            <NA>\r\n13  Lissamphibia            <NA>               <NA>            <NA>\r\n14          <NA> Labyrinthodonta               <NA>            <NA>\r\n15          <NA>       Salientia               <NA>            <NA>\r\n16    Neognathae            <NA>               <NA>            <NA>\r\n17    Neognathae            <NA>               <NA>            <NA>\r\n18 Palaeognathae            <NA>            Ratitae            <NA>\r\n19 Palaeognathae            <NA>            Ratitae            <NA>\r\n20          <NA>            <NA>               <NA>            <NA>\r\n   rank_subdivision zoology         rank_order\r\n10                     <NA>            Salpida\r\n11                     <NA>       Myxiniformes\r\n12                     <NA> Petromyzontiformes\r\n13                     <NA>              Anura\r\n14                     <NA>      Temnospondyli\r\n15                     <NA>       Sphenodontia\r\n16                     <NA>   Accipititrifomes\r\n17                     <NA>    Phaethontifomes\r\n18                     <NA>      Casuariifomes\r\n19                     <NA>   Dinornithiformes\r\n20                     <NA>       Anseriformes\r\n\r\nThese missing values will show up as empty sections in the resulting diagram, which isn’t ideal. Instead, we can build this data.frame so as to place all nodes in order by row, with empty ‘levels’ being placed at the end. This also avoids the problem where ‘unnamed’ ranks are grouped in the same column. To achieve this, we simply choose a different node attribute (level in this case) to supply to the type argument.\r\n\r\n\r\ndf_level <- ToDataFrameTypeCol(chordate_orders, type = \"level\")\r\ndf_level[10:20, ]\r\n\r\n\r\n    level_1    level_2       level_3        level_4\r\n10 Chordata   Tunicata     Thaliacea        Salpida\r\n11 Chordata Vertebrata       Agnatha         Myxini\r\n12 Chordata Vertebrata       Agnatha Petromyzontida\r\n13 Chordata Vertebrata Gnathostomata       Amphibia\r\n14 Chordata Vertebrata Gnathostomata       Amphibia\r\n15 Chordata Vertebrata Gnathostomata       Amphibia\r\n16 Chordata Vertebrata Gnathostomata           Aves\r\n17 Chordata Vertebrata Gnathostomata           Aves\r\n18 Chordata Vertebrata Gnathostomata           Aves\r\n19 Chordata Vertebrata Gnathostomata           Aves\r\n20 Chordata Vertebrata Gnathostomata           Aves\r\n              level_5          level_6          level_7 level_8\r\n10               <NA>             <NA>             <NA>    <NA>\r\n11       Myxiniformes             <NA>             <NA>    <NA>\r\n12 Petromyzontiformes             <NA>             <NA>    <NA>\r\n13       Lissamphibia            Anura             <NA>    <NA>\r\n14    Labyrinthodonta    Temnospondyli             <NA>    <NA>\r\n15          Salientia     Sphenodontia             <NA>    <NA>\r\n16         Neognathae Accipititrifomes             <NA>    <NA>\r\n17         Neognathae  Phaethontifomes             <NA>    <NA>\r\n18      Palaeognathae          Ratitae    Casuariifomes    <NA>\r\n19      Palaeognathae          Ratitae Dinornithiformes    <NA>\r\n20       Anseriformes             <NA>             <NA>    <NA>\r\n\r\nAnother problem in this dataset is the existence of duplicated taxonomic names. This happens because different authorities place the same taxon in different parts of the tree, and while the ALA tries to clean up these issues, some disagreements remain. The code below assumes that each name is only present once, so we have to remove duplicates to proceed. Fortunately there is a function in package base that flags duplcated values as TRUE and unique values as FALSE. We can use this function to identify rows where order is not unique.\r\n\r\n\r\nlibrary(dplyr)\r\nkeep_rows <- !duplicated(df_rank$rank_order)\r\ndf_rank <- filter(df_rank, keep_rows)\r\ndf_level <- filter(df_level, keep_rows)\r\n\r\n\r\n\r\nThe next step is to determine how to represent this structure in a plot. At the moment we can’t do this, because the data are in ‘wide’ format. Instead, we need to reorder our data so that each node/taxon is represented once, and other plotting aesthetics can be added as additional columns. To achieve this, we first convert to ‘long’ format, preserving information like what row and column each taxonomic label was recorded in.\r\n\r\n\r\ndf_long <- tibble(\r\n  row = rep(seq_len(nrow(df_level)), ncol(df_level)),\r\n  level = rep(seq_len(ncol(df_level)), each = nrow(df_level)),\r\n  taxon = do.call(c, df_level)) |> \r\n  filter(!is.na(taxon)) # remove missing values\r\n\r\n\r\n\r\nThen, we can summarize this plot so that each row is a single taxon, recording some metadata about rows and columns from the original dataset\r\n\r\n\r\ndf_plot <- df_long |>\r\n  group_by(taxon) |>\r\n  summarize(\r\n    xmin = min(row) - 1, \r\n    xmax = max(row), \r\n    ymin = level[1] - 1,\r\n    ymax = level[1])\r\n     \r\ndf_plot\r\n\r\n\r\n# A tibble: 161 x 5\r\n   taxon             xmin  xmax  ymin  ymax\r\n   <chr>            <dbl> <int> <dbl> <int>\r\n 1 Acanthopterygii     66    79     6     7\r\n 2 Accipititrifomes    15    16     5     6\r\n 3 Accipitriformes     21    22     4     5\r\n 4 Actinopterygii      56    96     4     5\r\n 5 Agnatha             10    12     2     3\r\n 6 Albuliformes        62    63     6     7\r\n 7 Amphibia            12    15     3     4\r\n 8 Amphioxi             0     1     2     3\r\n 9 Amphioxiformes       0     1     3     4\r\n10 Anguilliformes      63    64     6     7\r\n# ... with 151 more rows\r\n\r\nDrawing\r\nOur dataset now contains all the information we need to plot the structure of our taxonomic tree. As usual, we’re going to plot this with ggplot2.\r\n\r\n\r\nlibrary(ggplot2)\r\nggplot(df_plot) +\r\n  geom_rect(\r\n    mapping = aes(\r\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \r\n      group = taxon,\r\n      fill = ymax),\r\n    color = \"white\")\r\n\r\n\r\n\r\n\r\nWhile this is (probably) accurate, it’s not very informative. The most obvious missing element is labels; to add these, we’ll need to determine which nodes are ‘leaves’, and which are ‘branches’. We’ll also want to restrict labelling to larger branches, to avoid the text looking crowded. Finally, there is no need to label leaves with both a rectangle and text; so we’ll remove the leaf rectangles from the plot.\r\n\r\n\r\ndf_plot <- df_plot |> mutate(\r\n  x_dist = xmax - xmin,\r\n  is_leaf = taxon %in% df_rank$rank_order)\r\n\r\np <- ggplot() +\r\n  geom_rect(\r\n    data = filter(df_plot, !is_leaf),\r\n    mapping = aes(\r\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \r\n      group = taxon,\r\n      fill = ymax),\r\n    color = \"white\")\r\n\r\np +\r\n  # branch labels\r\n  geom_text(\r\n    data = filter(df_plot, x_dist > 5),\r\n    mapping = aes(\r\n      x = xmin + (x_dist * 0.5), \r\n      y = ymin + 0.5,\r\n      label = taxon),\r\n    color  = \"white\",\r\n    size = 3) +\r\n  # leaf labels\r\n  geom_text(\r\n    data = filter(df_plot, is_leaf),\r\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\r\n    angle = 90,\r\n    hjust = 0,\r\n    size = 2.5,\r\n    color = \"grey20\") \r\n\r\n\r\n\r\n\r\nThis is better, but not ideal. A much more pleasing look is to use coord_polar() to generate a circular plot; but this leads to linear text on a circular plot, which looks messy. Fortunately, the new package geomtextpath solves this problem. All we have to do is replace geom_text with geom_textpath, leaving all other code the same, and add coord_polar() at the end.\r\n\r\n\r\nlibrary(geomtextpath)\r\n\r\np <- p + \r\n  geom_textpath(\r\n    data = filter(df_plot, x_dist > 5),\r\n    mapping = aes(\r\n      x = xmin + (x_dist * 0.5), \r\n      y = ymin + 0.5,\r\n      label = taxon),\r\n    color  = \"white\",\r\n    size = 2.7) +\r\n  geom_textpath(\r\n    data = filter(df_plot, is_leaf),\r\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\r\n    angle = 90,\r\n    hjust = 0,\r\n    size = 2.3,\r\n    color = \"grey20\") +\r\n  coord_polar()\r\np\r\n\r\n\r\n\r\n\r\nFinally, we can add some finishing touches by changing the color scheme, hiding the background colors and legend, and resizing the y axis so all the labels are visible.\r\n\r\n\r\nlibrary(viridis)\r\n\r\np +\r\n  scale_fill_viridis(begin = 0, end = 0.9, direction = -1) +\r\n  lims(y = c(0, 9)) +\r\n  theme_void() + \r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nDone! This is a fun plot, but there are ways it could be expanded or improved, the most obvious of which is to find ways to add supplementary information. Wouldn’t it be great, for example, to add leaf-level record counts as marginal barplots? Or scale the size of segments to the number of records, rather than the number of clades? While none of these are impossible, I’m going to leave this here for now. I hope you like the result!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-20_creating-a-color-palette-from-an-image/",
    "title": "Creating a color palette from an image",
    "description": "There are hundreds of color palettes in the R ecosystem, but sometimes we\nmight want to use colors from a specific image. Here I show how to \nuse the `paletter` package to create a color palette for the 2020 Eucalypt of \nthe Year: the Western Australian Gimlet.",
    "author": [
      {
        "name": "Martin Westgate",
        "url": {}
      }
    ],
    "date": "2021-03-20",
    "categories": [
      "Summaries",
      "Eukaryota",
      "Plantae"
    ],
    "contents": "\r\n\r\nContents\r\nColors in R\r\nExtracting colors\r\nCreating a plot\r\n\r\n\r\n\r\n\r\n\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMartin Westgate\r\n\r\nDate:\r\n\r\nMarch 2021\r\n\r\n\r\n\r\nColors in R\r\nColor palettes are important to people, and the R ecosystem includes literally hundreds of possible palettes. If you want a “complete” list, go and check out Emil Hvitfeldt’s list of palettes here; but in practice there are only a few that we use routinely. Our default at ALA labs is to use viridis for continuous scales, because (to quote their CRAN page) it’s color-blind friendly, perceptually uniform, and pretty. The default purple-green-yellow color scheme is lovely, but I’m a big fan of ‘magma’, which has a black-purple-orange-yellow scheme\r\n\r\n\r\nlibrary(galah)\r\nlibrary(ggplot2)\r\nlibrary(viridis)\r\n\r\nrecords <- ala_counts(group_by = \"cl22\")\r\nrecords$State <- factor(seq_len(nrow(records)), labels = records$cl22) \r\n\r\nggplot(records, aes(x = State, y = log10(count), fill = count)) + \r\n  geom_bar(stat = \"identity\") +\r\n  coord_flip() +\r\n  scale_fill_viridis(option = \"magma\", begin = 0.10, end = 0.95) +\r\n  theme_bw() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nMy default for categorical color schemes is the ‘dark2’ palette from RColorBrewer; but given the subject matter of our work, it’s worth mentioning the wonderful feather package by Shandiya Balasubramaniam, which gives colors based on Australian bird plumage\r\n\r\n\r\n# remotes::install_github(repo = \"shandiya/feathers\")\r\nlibrary(feathers)\r\n\r\nrcfd <- ala_counts(\r\n  taxa = select_taxa(\"Rose-crowned Fruit-Dove\"),\r\n  group_by = \"cl22\")\r\nrcfd$State <- factor(seq_len(nrow(rcfd)), labels = rcfd$cl22) \r\n\r\nggplot(rcfd, aes(x = State, y = log10(count), fill = State)) + \r\n  geom_bar(stat = \"identity\") +\r\n  coord_flip() +\r\n  scale_fill_manual(values = get_pal(\"rose_crowned_fruit_dove\")) +\r\n  theme_bw() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nAll of this is fine, but what if you have a specific image that you want to take colors from? A logical choice is to pick the colors you want using an image editting program, but if we want to try something automated, there are options in R as well.\r\nExtracting colors\r\nNational Eucalypt Day aims to raise awareness about Eucalypts and celebrate their influence on the lives of Australians. In honour of National Eucalypt day, we wanted to created a plot based on occurrences data held in the Atlas of Living Australia, themed using colours from actual Eucalypts.\r\nWe used this image from a tweet by Dean Nicolle:\r\n\r\nHappy 'National Eucalypt Day'!The Western Australian gimlet (Eucalyptus salubris) has just been announced as Eucalypt of the Year for 2021. Renowned for its fluted, smooth, shiny, and colourful trunk & branches. pic.twitter.com/pOsufQtxWS— Dean Nicolle (@DeanNicolle1) March 22, 2021\r\n\r\n\r\nImage of Eucalyptus salubris by Dean NicolleFirst, get observations of the Eucalypt of the Year 2021 from ALA using the galah package. Specifically, we use ala_counts() to determine how many records of Eucalyptus salubris are held by the ALA:\r\n\r\n\r\nn_records <- ala_counts(taxa = select_taxa(\"Eucalyptus salubris\"))\r\n\r\n\r\n\r\nThen get a color scheme from images of the species in question using the paletter package (which needs to be installed from GitHub) \r\n\r\n\r\n# remotes::install_github(\"AndreaCirilloAC/paletter\")\r\nlibrary(paletter)\r\n\r\nimage_pal <- create_palette(\r\n  image_path = \"./data/Dean_Nicolle_Esalubris_image_small.jpeg\",\r\n  type_of_variable = \"categorical\",\r\n  number_of_colors = 15)\r\n\r\n\r\n\r\n\r\n\r\n\r\nNote that we downsized the image before running the paletter code, as large images take much longer to process.\r\nCreating a plot\r\nOnce we have this palette, the obvious question is what kind of plot to draw. We could have done a map, but those can be a bit boring. We decided to try something that represented the number of observations we had of this species at ALA, and included color, but was otherwise just a pretty picture that didn’t need to contain any further information. Rather than have a traditional x and y axis, therefore, we decided to try out the igraph package to plot the points in an interesting way.\r\nFirst, we create a vector containing as many points as we want to display, and distribute our colors among them as evenly as possible\r\n\r\n\r\n# create a vector to index colours\r\ncolour_index <- rep(seq_along(image_pal),\r\n  each = floor(n_records / length(image_pal)))\r\n# correct rounding errors\r\ncolour_index <- c(colour_index,\r\n  rep(length(image_pal), n_records - length(colour_index)))\r\n\r\n\r\n\r\nThen we can create a network using igraph, and use it to create a layout for our points\r\n\r\n\r\nlibrary(igraph)\r\n\r\ngraph_list <- lapply(c(1:15), function(a){\r\n  lookup <- which(colour_index == a)\r\n  return(data.frame(\r\n    from = lookup[c(1:(length(lookup)-1))],\r\n    to = lookup[c(2:length(lookup))]))\r\n  })\r\ngraph_df <- as.matrix(do.call(rbind, graph_list))         # build matrix\r\ncolour_graph <- graph_from_edgelist(graph_df)             # create network graph\r\n\r\n# convert to a set of point locations\r\ntest_layout <- as.data.frame(layout_nicely(colour_graph)) # convert to df\r\ncolnames(test_layout) <- c(\"x\", \"y\")                      # change colnames\r\ntest_layout$colour_index <- factor(colour_index)          # add colour_index col\r\n\r\n\r\n\r\nFinally, we draw the plot with ggplot2, removing axes with theme_void()\r\n\r\n\r\nggplot(test_layout, aes(x = x, y = y, colour = colour_index)) +\r\n  geom_point(size = 3, alpha = 0.9) +\r\n  scale_color_manual(values = image_pal) +\r\n  coord_fixed() +\r\n  theme_void() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nThat’s it! While I like the effect here, I think the paletter package is best suited to cases where there are large areas of strongly contrasting colors; it’s less ideal for images with subtle color differences. It also doesn’t appear to have been updated lately, which may mean it’s not being supported any more. But I’m happy with this plot, and would definitely consider using it again.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-20_creating-a-color-palette-from-an-image/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  }
]
