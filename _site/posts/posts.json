[
  {
    "path": "posts/2022-10-12_alpha-hulls/",
    "title": "Convex and alpha hulls for conservation mapping",
    "description": "Convex hulls and alpha hulls are wonderful alternatives for visualising species distributions \nwhen a species has very few existing observations.\nHere, we will show you how to create these spatial polygons using data\nfrom the ALA.",
    "author": [
      {
        "name": "Margot Schneider",
        "url": {}
      },
      {
        "name": "Fonti Kar",
        "url": {}
      }
    ],
    "date": "2022-10-20",
    "categories": [
      "Summaries",
      "Maps",
      "Eukaryota",
      "Animalia"
    ],
    "contents": "\r\n\r\nContents\r\nDownload\r\ndata\r\nMap a convex\r\nhull\r\nWhat\r\nis an alpha hull?\r\nMap an alpha\r\nhull\r\nAlpha hull with filtered\r\nobservations\r\n\r\nA\r\nreal-life example\r\nFinal\r\nthoughts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMargot\r\nSchneider Fonti\r\nKar\r\n\r\n\r\nDate:\r\n\r\n20 October, 2022\r\n\r\n\r\n\r\n\r\n\r\nThe ability to predict where a species resides is important in\r\nconservation ecology, but when a species has very few existing\r\nobservations (i.e. a data-deficient species), predicting its\r\ndistribution can be difficult (or impossible) using standard methods for\r\nspecies distributions.\r\nConvex hulls and alpha hulls are\r\ntwo ways to plot the spatial distribution of data-deficient species,\r\nmaking it possible to calculate metrics that help us predict whether a\r\nspecies is threatened to become extinct (i.e. IUCN\r\nmetrics).\r\nRecently, Dr. Marsh\r\nand colleagues used alpha hulls to estimate the impact of the 2020\r\nmega bushfires on invertebrates in southern Australia. Since\r\ninvertebrate data is inherently sparse, alpha hulls are really useful\r\nwhen you only have a handful of records to work with.\r\nIn this post, we’ll explain the difference between convex hulls and\r\nalpha hulls and show you how to make them yourself!\r\nDownload data\r\nTo illustrate the various spatial polygons you can make, let’s look\r\nat an invertebrate species from Dr. Marsh’s study: an endemic damselfly,\r\nAustroargiolestes calcaris, commonly known as the Powdered\r\nFlatwing\r\n\r\n\r\n\r\nFigure 1: A\r\nPowdered Flatwing perched on a plant by Reiner Richter CC-BY 4.0\r\n\r\n\r\n\r\nFirst we will load the R packages we’ll need:\r\n\r\n\r\n# install.packages(\"pacman\")\r\npacman::p_load(remotes, galah, tidyverse, alphahull, \r\n               sp, sf, ozmaps, patchwork)\r\n\r\n\r\nNow let’s use galah to download occurrence records from\r\nthe Atlas of Living Australia\r\n(ALA). Note that you will need to first enter a registered\r\nemail with the ALA using galah_config before fetching\r\nrecords.\r\n\r\n\r\n# Add registered email (register at ala.org.au)\r\ngalah_config(email = \"your-email@email.com\")\r\n\r\n\r\n\r\n\r\n# Download Powdered flatwing records \r\ngalah_call() |> \r\n  galah_identify(\"Austroargiolestes calcaris\") |> \r\n  galah_filter(profile=\"ALA\") |> \r\n  galah_select(group = \"basic\") |> \r\n  atlas_occurrences() -> dfly\r\n\r\n# See first 10 rows\r\ndfly |> head(10L)\r\n\r\n# A tibble: 10 × 8\r\n   decimalLa…¹ decim…² event…³ scien…⁴ taxon…⁵ recor…⁶ dataR…⁷ occur…⁸\r\n         <dbl>   <dbl> <chr>   <chr>   <chr>   <chr>   <chr>   <chr>  \r\n 1       -38.5    147. 2016-1… Austro… https:… 20b351… iNatur… PRESENT\r\n 2       -38      146. 2011-1… Austro… https:… d4e2c9… Reiner… PRESENT\r\n 3       -38.0    146. 2010-0… Austro… https:… 0c69fb… iNatur… PRESENT\r\n 4       -38.0    146. 2009-1… Austro… https:… b01df3… Reiner… PRESENT\r\n 5       -38.0    146. 2009-1… Austro… https:… 2ed539… Reiner… PRESENT\r\n 6       -38.0    146. 2018-0… Austro… https:… 586eb7… iNatur… PRESENT\r\n 7       -38.0    146. 2015-1… Austro… https:… 125786… Reiner… PRESENT\r\n 8       -37.9    145. 2004-1… Austro… https:… 9ff508… Reiner… PRESENT\r\n 9       -37.9    145. 2016-1… Austro… https:… fae8d5… ALA sp… PRESENT\r\n10       -37.9    145. 2019-1… Austro… https:… faae5f… iNatur… PRESENT\r\n# … with abbreviated variable names ¹​decimalLatitude,\r\n#   ²​decimalLongitude, ³​eventDate, ⁴​scientificName, ⁵​taxonConceptID,\r\n#   ⁶​recordID, ⁷​dataResourceName, ⁸​occurrenceStatus\r\n\r\nBefore we can plot anything, we will also need to remove all\r\nduplicated values and any NA values!\r\n\r\n\r\n# Remove duplicates & NAs\r\ndfly |> \r\n  filter(!duplicated(decimalLongitude) & !duplicated(decimalLatitude)) |> \r\n  filter(!is.na(decimalLongitude) & !is.na(decimalLatitude) ) -> dfly_clean\r\n\r\n\r\nMap a convex hull\r\nA convex hull is a way to draw around all the points\r\nof a species on a map with as few lines as possible. It’s defined as the\r\nsmallest polygon that encloses all the points in the data\r\nset.\r\nTo plot a convex hull on a map, we can use chull() to\r\ncompute a convex hull from our cleaned Powdered Flatwing data.\r\nchull() computes a series of points that make up our convex\r\nhull.\r\n\r\n\r\n# Compute convex hull\r\ndfly_clean |> \r\n  dplyr::select(decimalLongitude, decimalLatitude) |>  \r\n  chull() -> dfly_chull\r\n\r\ndfly_chull\r\n\r\n [1] 134 133   1  18  34  48 119 122 204 365 324\r\n\r\nNext, we join the first point of the hull vector to the last point,\r\ncreating a closed outline which can be plotted on a map.\r\n\r\n\r\n# Join first point of hull to the last point\r\ndfly_chull_pts <- c(dfly_chull, dfly_chull[1])\r\n\r\n\r\nNow we can get a map of Australia from the {ozmaps}\r\npackage and use st_transform() to make sure it has the\r\ncorrect projection of 4326.\r\n\r\n\r\n# Get map of Australia\r\naus <- st_transform(ozmaps::ozmap_country, 4326)\r\n\r\n\r\nAnd finally, we plot our Powdered Flatwing occurrence records and its\r\nconvex hull on a map!\r\n\r\n\r\n# Plot occurrences and convex hull\r\nggplot() + \r\n  geom_sf(data = aus, \r\n          colour = \"black\", \r\n          fill = \"white\")  + \r\n  geom_point(data = dfly_clean, \r\n             mapping = aes(decimalLongitude, decimalLatitude), \r\n             colour = \"black\", size = 0.8) + \r\n  geom_polygon(data = dfly_clean[dfly_chull_pts, ], \r\n               mapping = aes(decimalLongitude, decimalLatitude), \r\n               fill = \"orange\", \r\n               colour = \"black\", \r\n               alpha = 0.5) + \r\n  coord_sf(xlim=c(142, 152), \r\n           ylim=c(-32,-44)) +\r\n  labs(title = \"Convex hull\", \r\n       x = \"Longtitude (DD)\", \r\n       y = \"Latitude (DD)\") + ## DD here stands for decimal degrees\r\n  theme_bw()\r\n\r\n\r\n\r\nWhat is an alpha hull?\r\nLike a convex hull, an alpha hull is also a way to\r\ndraw the smallest polygon that encloses all the points in a data set.\r\nHowever, alpha hulls differ because they use an alpha\r\nparameter to control how tightly the boundary fits around a set\r\nof points. This method creates concave, arched edges that fit around\r\noccurrence records more tightly. A tighter boundary around our points\r\nhelps us avoid over-predicting the range of a species.\r\nTo illustrate, here are three alpha hulls with increasing\r\nvalues for alpha. Notice as the alpha value increases, the tightness of\r\nour boundary decreases.\r\n\r\nExpand for code to create maps\r\n\r\n\r\n# Compute alpha shapes and store in list column within a tibble\r\ntibble(\r\n  alpha_value = c(1, 2, 5),\r\n  ahull_ls = map(.x = c(1, 2, 5),\r\n                 .f = ~ dfly_clean |> \r\n                   select(decimalLongitude, decimalLatitude) |> \r\n                   ahull(alpha = .x)) \r\n) -> dfly_ahulls\r\n\r\n\r\n# Transform alpha hull to an `sp` object and set map projection to 4326\r\nset_map_proj <- function(sp_obj){\r\nsp_obj@proj4string <- sp::CRS(\"EPSG:4326\") \r\n\r\nsp_obj\r\n}\r\n\r\ndfly_ahulls |> \r\n  mutate(ahull_sp = map(.x = ahull_ls,\r\n                        .f = hull2spatial::ahull2poly),\r\n         ahull_sp = map(.x = ahull_sp,\r\n                        .f = set_map_proj)\r\n         ) -> dfly_ahulls\r\n\r\n\r\n# Transform `sp` object into a `sf` object \r\ndfly_ahulls |> \r\n  mutate(ahull_sf = map(.x = ahull_sp,\r\n                        .f = st_as_sf)\r\n         ) -> dfly_ahulls\r\n\r\n# Transform occurrences into `sf` object for plotting\r\nst_as_sf(dfly_clean, \r\n         coords = c(\"decimalLongitude\", \"decimalLatitude\"), \r\n         crs = 4326) -> dfly_sf\r\n\r\n## A function to compose map \r\nplot_ahull_fun <- function(ahull_sf, title = NULL){\r\n  p <- ggplot() + \r\n    geom_sf(data = aus, colour = \"black\", fill = \"white\")  +\r\n    geom_sf(data = dfly_sf, colour = \"black\", size = 0.5) +  \r\n    geom_sf(data = ahull_sf, fill = \"orange\", alpha = 0.5) +\r\n    coord_sf(xlim=c(142, 152),ylim=c(-32,-44)) +\r\n    ggtitle(paste(\"a = \", as.character(title))) +\r\n    labs(x = \"Longtitude (DD)\", y = \"Latitude (DD)\") + \r\n    theme_bw(base_size = 12)\r\n  \r\n  p\r\n}\r\n\r\ndfly_ahulls |> \r\n  mutate(ahull_maps = map2(.x = ahull_sf,\r\n                           .y = alpha_value,\r\n                           .f = ~ plot_ahull_fun(.x , .y)) \r\n  ) -> dfly_ahulls\r\n\r\n\r\n\r\n\r\n\r\nAlpha = 2 is the alpha value we’ve most commonly\r\ncome across in research, and is the value recommended by the IUCN for\r\nvarious forms of species vulnerability analysis.\r\nSo, let’s learn how to make the a = 2 plot\r\nabove!\r\nMap an alpha hull\r\nTo make an alpha hull, we will rely on the hull2spatial\r\npackage (developed by Cecina Babich Morrow). This package allows us to\r\nconvert “ahull” objects into ggplot-friendly objects (to\r\nlearn more, check\r\nout their blog post about the package).\r\nInstall the package from GitHub using:\r\n\r\n\r\nremotes::install_github(\"babichmorrowc/hull2spatial\")\r\nlibrary(hull2spatial)\r\n\r\n\r\nTo compute our alpha hull, we’ll provide the longitude and latitude\r\ncoordinates of our data points to the ahull() function, and\r\nset alpha = 2. ahull() creates a\r\nlist object with far more complexity than our convex hull.\r\nA nice way to understand the difference is to look at the first 5 rows\r\nof the arcs component of our list dfly_ahull,\r\nwhich stores information like the center and radius of each arch in our\r\nalpha hull.\r\n\r\n\r\n# Compute an alpha hull\r\ndfly_clean |> \r\n  dplyr::select(decimalLongitude, decimalLatitude) |> \r\n  ahull(alpha = 2) -> dfly_ahull\r\n\r\n# See first 5 values of `arcs` component of list\r\ndfly_ahull$arcs |> head(5L)\r\n\r\n           c1        c2 r       v.x       v.y       theta end1 end2\r\n[1,] 144.8341 -39.83458 2 0.3890667 0.9212096 0.009959896    2    4\r\n[2,] 144.8227 -39.82989 2 0.3508991 0.9364133 0.037253656    4   10\r\n[3,] 144.7963 -39.82087 2 0.3060905 0.9520024 0.024179028   10   18\r\n[4,] 143.7084 -39.02735 2 0.8254355 0.5644964 0.002581065   18   34\r\n[5,] 143.6389 -38.91884 2 0.8574929 0.5144958 0.002478157   34   48\r\n\r\nNext we’ll transform our alpha hull and occurrence points into\r\nspatial objects for plotting.\r\nThe ahull2poly() function converts our alpha hull to one\r\ntype of spatial object (an sp object), but we’ll use\r\nst_as_sf() to convert our result to an sf\r\nobject (because it’s easier to plot) and set our map projection to\r\n4326. We’ll do the same for our damselfly occurrence\r\npoints.\r\n\r\n\r\n# Transform  `ahull` into spatial object, convert to sf, set coordinates\r\nhull2spatial::ahull2poly(dfly_ahull) |> \r\n  st_as_sf() |> \r\n  st_set_crs(st_crs(aus)) -> dfly_sf_ahull\r\n\r\n# Convert occurrence points to `sf` for plotting\r\ndfly_clean |> \r\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \r\n           crs = 4326) -> dfly_sf\r\n\r\n\r\nFinally, we can create our plot!\r\n\r\n\r\n# Plot the occurrences and alpha hull\r\nggplot() + \r\n  geom_sf(data = aus, colour = \"black\", fill = \"white\")  +\r\n  geom_sf(data = dfly_sf, colour = \"black\", size = 0.5) +  \r\n  geom_sf(data = dfly_sf_ahull, fill = \"orange\", alpha = 0.5) +\r\n  coord_sf(xlim=c(142, 152),ylim=c(-32,-44)) +\r\n  ggtitle(\"Alpha hull\") +\r\n  labs(x = \"Longtitude (DD)\", y = \"Latitude (DD)\") + \r\n  theme_bw()\r\n\r\n\r\n\r\nAlpha hull with filtered\r\nobservations\r\nCitizen science data are often excluded from scientific analyses due\r\nto poor data quality e.g. rare species can be misidentified by someone\r\nwho’s not an expert. Although a strict data criteria will reduce the\r\nnumber of data points, we can still compute and plot alpha hulls for the\r\nPowdered Flatwing - this is the beauty of them!\r\nLet’s repeat exactly the same steps as above for generating an alpha\r\nhull, but only use a subset of our damselfly observations that comes\r\nfrom specimen data. We can do this by specifying the\r\nbasisOfRecord with galah_filter().\r\n\r\n\r\n# Create a vector excluding human observations\r\ninstitution_only <- c(\"PRESERVED_SPECIMEN\", \"LIVING_SPECIMEN\", \r\n                   \"MACHINE_OBSERVATION\", \"MATERIAL_SAMPLE\")\r\n\r\ngalah_call() |> \r\n  galah_identify(\"Austroargiolestes calcaris\") |> \r\n  galah_filter(basisOfRecord == institution_only,\r\n               profile = \"ALA\") |> \r\n  galah_select(group = \"basic\") |> \r\n   atlas_occurrences() -> dfly_specionly\r\n\r\n\r\nBelow is our alpha hull of our specimen-only damselfly data. You’ll\r\nnotice that there are two separate hulls in this map!\r\nThis is another benefit of using an alpha hull over a convex hull. The\r\nmathematical constraints of a convex hull mean all points must be\r\ncontained within a single polygon - this can lead to an over-estimation\r\nof a species’ range.\r\n\r\n\r\n\r\nA real-life example\r\nAlpha hulls, and their ability to generate multiple hulls when data\r\nis sparse, can help us understand how sensitive certain species are to\r\nenvironmental change over time, even when species have few existing\r\nobservations.\r\nFor example, Dr. Takach\r\nand their team wanted to investigate how the distribution of mammals\r\nin the tropical savanna like Mesembriomys\r\ngouldii (the Black-Footed Tree Rat) shrink or expand in\r\nresponse to pressures like habitat loss and changing climate. Using\r\nalpha hulls, they found that the ecological niche of this species has\r\nshrunk due to a loss of suitable habitat over time.\r\n\r\n\r\n\r\nFigure 2: A Black-Footed Tree Rat perched on a branch by\r\nColin Trainor CC-BY-NC 4.0](https://images.ala.org.au/image/a197988c-5da5-4260-8f2a-5bb55b468fce)\r\n\r\n\r\n\r\nThe published paper didn’t provide a visual of this species’\r\ndistribution, so we’ve made a map below with ALA data to show the change\r\nin distribution over time:\r\n\r\nExpand for code to create map\r\n\r\n\r\n# Download records\r\ngalah_call() |> \r\n  galah_identify(\"Mesembriomys gouldii\") |> \r\n  galah_filter(profile = \"ALA\") |> \r\n  galah_select(group = \"basic\") |> \r\n  atlas_occurrences() -> tree_rat\r\n\r\n# Remove duplicates and NAs\r\ntree_rat |> \r\n  filter(! duplicated(decimalLongitude) & ! duplicated(decimalLatitude)) |> \r\n  filter(! is.na(decimalLongitude) & ! is.na(decimalLatitude) ) -> tree_ratclean\r\n\r\n# Convert occurrence points to sf for plotting\r\ntree_ratclean |> \r\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \r\n           crs = 4326) -> tree_rat_sf\r\n\r\n# Compute alpha hull\r\ntree_ratclean |> \r\n  select(decimalLongitude, decimalLatitude) |> \r\n  ahull(alpha = 2) -> tree_rat_ahull\r\n\r\n# Transform `ahull` to `sf`, set projection\r\nhull2spatial::ahull2poly(tree_rat_ahull) |> \r\n  st_as_sf() |>\r\n  st_set_crs(st_crs(aus)) -> tree_rat_sf_ahull\r\n\r\n# Convert occurrence points to sf for plotting\r\ntree_ratclean |> \r\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \r\n           crs = 4326) -> tree_rat_sf\r\n\r\n# Get map of Australia & set projection\r\naus <- st_transform(ozmaps::ozmap_country, 4326)\r\n\r\n#---\r\n\r\n# Download tree rat records after 2000\r\ngalah_call() |>\r\n  galah_identify(\"Mesembriomys gouldii\") |>\r\n  galah_filter(profile = \"ALA\",\r\n               year >= 2000,) |>\r\n  galah_select(group = \"basic\") |>\r\n  atlas_occurrences() -> Rtree_rat\r\n\r\n# Remove duplicates & exclude NAs\r\nRtree_rat |> \r\n  filter(!duplicated(decimalLongitude) & !duplicated(decimalLatitude)) |> \r\n  filter(!is.na(decimalLongitude) & !is.na(decimalLatitude) ) -> Rtree_ratclean\r\n\r\n# Compute an alpha hull for our specimen only occurrences\r\nRtree_ratclean |> \r\n  select(decimalLongitude, decimalLatitude) |> \r\n  ahull(alpha = 2) -> Rtree_rat_ahull\r\n\r\n# Transform `ahull` to sf, set coordinates\r\nhull2spatial::ahull2poly(Rtree_rat_ahull) |> \r\n  st_as_sf() |> \r\n  st_set_crs(st_crs(aus)) -> Rtree_rat_sf_ahull\r\n\r\n# Transform occurrence points to sf for plotting \r\nRtree_ratclean |> \r\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \r\n           crs = 4326) -> Rtree_rat_sf\r\n\r\n#---\r\n\r\n# Nice title\r\nrat_title <- expression(italic(\"Mesembriomys gouldii \"), \"alpha hulls\")\r\n\r\n# Plot!\r\nggplot() + \r\n  geom_sf(data = aus, colour = \"black\", fill = \"white\")  +\r\n  geom_sf(data = tree_rat_sf_ahull, aes(fill = \"chartreuse3\") ,alpha = 0.5, colour = \"black\", position = \"identity\") +\r\n    geom_sf(data = Rtree_rat_sf_ahull, aes(fill = \"blueviolet\"), alpha = 0.5, colour = \"black\", position = \"identity\") +\r\n  scale_fill_identity(guide = \"legend\",\r\n                      name = \"Record date ranges\",\r\n                      labels = c('2000 Onwards', 'All Records')) +\r\n  guides(colour = guide_legend(override.aes = list(alpha = 0.1))) +\r\n  coord_sf(xlim=c(125, 145),ylim=c(-20,-10)) +\r\n  ggtitle(rat_title) +\r\n  labs(x = \"Longtitude (DD)\", y = \"Latitude (DD)\") + \r\n  theme_bw() +\r\n  theme(legend.position = \"bottom\") -> combinedtree_rat_ahull_p\r\n\r\n\r\n\r\n\r\n\r\nFinal thoughts\r\nWhile sophisticated tools for modelling species distribution exist,\r\nthey require a lot of data to make reliable estimates. Convex\r\npolygons and alpha hulls are flexible\r\nalternatives that can help us understand dynamic changes to\r\ndistributions of understudied or vulnerable data-deficient species.\r\n\r\nExpand for session info\r\n\r\n─ Session info ─────────────────────────────────────────────────────\r\n setting  value\r\n version  R version 4.2.1 (2022-06-23 ucrt)\r\n os       Windows 10 x64 (build 19044)\r\n system   x86_64, mingw32\r\n ui       RStudio\r\n language (EN)\r\n collate  English_Australia.utf8\r\n ctype    English_Australia.utf8\r\n tz       Australia/Sydney\r\n date     2022-10-26\r\n rstudio  2022.07.1+554 Spotted Wakerobin (desktop)\r\n pandoc   2.19.2 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\r\n\r\n─ Packages ─────────────────────────────────────────────────────────\r\n package       * version date (UTC) lib source\r\n alphahull     * 2.5     2022-06-16 [1] CRAN (R 4.2.1)\r\n data.tree     * 1.0.0   2020-08-03 [1] CRAN (R 4.2.1)\r\n dplyr         * 1.0.10  2022-09-01 [1] CRAN (R 4.2.1)\r\n forcats       * 0.5.2   2022-08-19 [1] CRAN (R 4.2.1)\r\n galah         * 1.5.0   2022-10-17 [1] Github (AtlasOfLivingAustralia/galah@762b530)\r\n ggplot2       * 3.3.6   2022-05-03 [1] CRAN (R 4.2.1)\r\n ggraph        * 2.0.6   2022-08-08 [1] CRAN (R 4.2.1)\r\n here          * 1.0.1   2020-12-13 [1] CRAN (R 4.2.1)\r\n htmltools     * 0.5.3   2022-07-18 [1] CRAN (R 4.2.1)\r\n htmlwidgets   * 1.5.4   2021-09-08 [1] CRAN (R 4.2.1)\r\n hull2spatial  * 0.1.0   2022-10-12 [1] Github (babichmorrowc/hull2spatial@921594f)\r\n kableExtra    * 1.3.4   2021-02-20 [1] CRAN (R 4.2.1)\r\n metathis      * 1.1.2   2022-08-11 [1] CRAN (R 4.2.1)\r\n ozmaps        * 0.4.5   2021-08-03 [1] CRAN (R 4.2.1)\r\n pacman        * 0.5.1   2019-03-11 [1] CRAN (R 4.2.1)\r\n parameters    * 0.18.2  2022-08-10 [1] CRAN (R 4.2.1)\r\n patchwork     * 1.1.2   2022-08-19 [1] CRAN (R 4.2.1)\r\n plotly        * 4.10.0  2021-10-09 [1] CRAN (R 4.2.1)\r\n purrr         * 0.3.4   2020-04-17 [1] CRAN (R 4.2.1)\r\n readr         * 2.1.2   2022-01-30 [1] CRAN (R 4.2.1)\r\n remotes       * 2.4.2   2021-11-30 [1] CRAN (R 4.2.1)\r\n rmarkdown     * 2.16    2022-08-24 [1] CRAN (R 4.2.1)\r\n sessioninfo   * 1.2.2   2021-12-06 [1] CRAN (R 4.2.1)\r\n sf            * 1.0-8   2022-07-14 [1] CRAN (R 4.2.1)\r\n sp            * 1.5-0   2022-06-05 [1] CRAN (R 4.2.1)\r\n stringr       * 1.4.1   2022-08-20 [1] CRAN (R 4.2.1)\r\n tibble        * 3.1.8   2022-07-22 [1] CRAN (R 4.2.1)\r\n tidygraph     * 1.2.2   2022-08-22 [1] CRAN (R 4.2.1)\r\n tidyr         * 1.2.0   2022-02-01 [1] CRAN (R 4.2.1)\r\n tidyverse     * 1.3.2   2022-07-18 [1] CRAN (R 4.2.1)\r\n xaringanExtra * 0.7.0   2022-07-16 [1] CRAN (R 4.2.1)\r\n\r\n [1] C:/Users/KEL329/R-packages\r\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.2.1/library\r\n\r\n────────────────────────────────────────────────────────────────────\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-10-12_alpha-hulls/distill-preview.png",
    "last_modified": "2022-10-26T12:26:44+11:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-07-22_sample-bias/",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "description": "Human biases play a large role in the data we collect about species. Here we show a simple method to quantify the bias of roads, cities, rivers and airports on species observations of legless lizards in the Northern Territory",
    "author": [
      {
        "name": "Dax Kellie",
        "url": {}
      }
    ],
    "date": "2022-08-08",
    "categories": [
      "Eukaryota",
      "Animalia",
      "Chordata",
      "Summaries"
    ],
    "contents": "\r\n\r\nContents\r\nDownload\r\ndata\r\nMake a map\r\nRun the\r\nmodel\r\nCheck your\r\nbias\r\nMap the bias\r\nOther\r\nspecies\r\nFinal\r\nthoughts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nDax\r\nKellie\r\n\r\n\r\nDate:\r\n\r\n8 August, 2022\r\n\r\n\r\n\r\n\r\n\r\nBeing human plays a big role in the species we observe, when we\r\nobserve them and where we observe them. In particular, we tend to\r\ncollect more data in areas that are closer to places we live (or have\r\naccess to) because there are more opportunities to see species in areas\r\nwe spend more time in than areas that are far away or inaccessible.\r\nLarge, public datasets like the Atlas of Living Australia are\r\nespecially prone to this sampling bias because they largely reflect\r\nopportunistic observations rather than systematic monitoring programs.\r\nHowever, not all species observations are affected equally by these\r\nbiases, and it’s useful to quantify how biased data are before\r\ninterpreting them.\r\nThanks to the sampbias\r\npackage, we can easily quantify and compare the effects of these\r\nbiases on our data, specifically whether data are influenced by cities,\r\nroads, airports and rivers.\r\nThis post expands on a\r\nTwitter thread by Dr Ian Brennan to show how sampling bias affects\r\nmuseum records of reptiles. Dr Brennan is currently a Post Doctoral\r\nresearcher at the Australian National University (ANU). Check out his website to learn more\r\nabout him and his cool research.\r\nDownload data\r\nTo begin, we will look at some of Dr Brennan’s favourite reptiles:\r\nlegless lizards from the genus Delma.\r\n\r\n\r\n\r\nFigure 1: Left: Delma\r\ndesmosa (tom_brennan CC BY-NC 4.0) Middle: Delma\r\ninornata (kenty_8881 CC BY-NC 4.0) Right: Delma\r\ntincta (Ryan Shofner CC BY-NC 4.0)\r\n\r\n\r\n\r\nFirst let’s load the packages we need.\r\n\r\n\r\nlibrary(sampbias)\r\nlibrary(galah)\r\nlibrary(viridis)\r\nlibrary(tidyverse)\r\nlibrary(ozmaps)\r\nlibrary(sf)\r\n\r\n\r\nNext we will use the galah\r\npackage to download occurrence records of Delma in the\r\nNorthern Territory from the Atlas of Living Australia (ALA).\r\n\r\n\r\n# Add registered email (register at ala.org.au)\r\ngalah_config(email = \"your-email@email.com\", verbose = FALSE)\r\n\r\n\r\n\r\n\r\n# Download Delma occurrence records in NT\r\ndelma_records <- galah_call() |>\r\n  galah_identify(\"Delma\") |>\r\n  galah_filter(stateProvince == \"Northern Territory\") |>\r\n  atlas_occurrences()\r\n\r\n# See first 10 rows\r\ndelma_records |> head(10L)\r\n\r\n# A tibble: 10 × 7\r\n   decimalLatitude decimalLongitude eventDate           scientificName\r\n             <dbl>            <dbl> <chr>               <chr>         \r\n 1           -26.0             134. 2008-09-26T14:00:0… Delma tincta  \r\n 2           -26.0             134. 2008-09-26T14:00:0… Delma tincta  \r\n 3           -26.0             135. 2008-09-25T14:00:0… Delma tincta  \r\n 4           -26.0             135. 2008-09-25T14:00:0… Delma tincta  \r\n 5           -25.9             135. 2008-09-25T14:00:0… Delma tincta  \r\n 6           -25.9             135. 2008-09-25T14:00:0… Delma tincta  \r\n 7           -25.9             135. 2008-09-25T14:00:0… Delma tincta  \r\n 8           -25.9             135. 2008-09-25T14:00:0… Delma tincta  \r\n 9           -25.9             135. 2008-09-25T14:00:0… Delma austral…\r\n10           -25.9             135. 2008-09-25T14:00:0… Delma austral…\r\n# … with 3 more variables: taxonConceptID <chr>, recordID <chr>,\r\n#   dataResourceName <chr>\r\n\r\nNow we can edit our data to select the columns we want, remove pesky\r\nNA values, and filter our records to make sure there are no\r\noutliers outside of the Northern Territory\r\n\r\n\r\ndelma_records_filtered <- delma_records |>\r\n  dplyr::select(scientificName, decimalLatitude, decimalLongitude) |>\r\n  drop_na() |>\r\n  filter(decimalLatitude < -10,\r\n         decimalLatitude >= -26,\r\n         decimalLongitude >= 129,\r\n         decimalLongitude <= 138) \r\n\r\n\r\nMake a map\r\nThe next step is to get a map of the Northern Territory that we will\r\nuse to calculate sample bias in our data. The ozmaps\r\npackage has excellent quality datasets of the Australian coastline,\r\nstate outlines, local municipality boundaries and electoral boundaries.\r\nWe can use filter() to extract mapping info of the Northern\r\nTerritory, and st_transform() and st_crs() to\r\nmake sure the map has the correct WGS84 projection for ALA data.\r\n\r\n\r\n# Get map\r\nnt_wgs84 <- ozmap_data(data = \"states\") |>\r\n  filter(NAME == \"Northern Territory\") |>\r\n  sf::st_transform(crs = sf::st_crs(\"WGS84\"))\r\n\r\n## check map\r\nggplot(nt_wgs84) + geom_sf(fill = \"transparent\")\r\n\r\n\r\n\r\nFor those unfamiliar with Australian geography, the Northern\r\nTerritory is this one:\r\n\r\n\r\n\r\nRun the model\r\nIt’s time to quantify the influence of roads, cities, airports and\r\nrivers on Delma records!\r\n{sampbias} uses a probabilistic method to quantify\r\naccessibility bias. You can check out their published\r\npaper if you’d like to know more about the Bayesian methods\r\nunderlying these estimates.\r\nWe use the calculate_bias() function to run our model.\r\nWe have specified that our model make estimates at a fine spatial scale\r\nresolution of res = 0.05 and we have added a buffer, which\r\nhelps our model account for any neighbouring features just outside of\r\nour specified area that might affect our data. We also make sure to\r\nrestrict our model to be within our map of the Northern Territory,\r\nensuring it is in the correct format by using\r\nsf:::as_Spatial(nt_wgs84).\r\nImportant Note: Fine scale resolutions increase\r\nhow long it takes for the model to run. This example took around 30\r\nminutes. If you are short on time, I’d suggest starting with a lower\r\nresolution like res = 0.5.\r\n\r\n\r\nmodel_bias_delma <- sampbias::calculate_bias(\r\n  x = delma_records_filtered,\r\n  res = 0.05,   # scale of spatial resolution\r\n  buffer = 0.5, # account for neighbouring features\r\n  restrict_sample = sf:::as_Spatial(nt_wgs84)\r\n)\r\n\r\n\r\n\r\n\r\n\r\nCheck your bias\r\nOnce the model finishes running, we can use plot() to\r\nsee the results.\r\nPlot A shows the strength of sampling bias from each\r\nspatial feature. A higher posterior weight indicates greater sampling\r\nbias. For Delma records, we can see airports (in yellow) are\r\nthe largest source of bias, followed by roads (in green), with rivers\r\nand cities adding relatively smaller amounts of bias.\r\nPlot B shows the effect of each biasing factor on\r\nthe sampling rate. Lines that curve more steeply indicate a larger\r\ndrop-off in the likelihood of an observation as we get further from each\r\nspatial feature. For Delma, getting further than 250 km from an\r\nairport effectively cuts the expected number of observations by around\r\nhalf.\r\nIt’s worth pointing out that {sampbias} uses data of\r\nmost major roads in Australia, but there are many smaller roads missing\r\nfrom the data informing this model (which you’ll be able to see in the\r\nnext section). As a result, the output may not be a perfect reflection\r\nof movement or bias in this region.\r\nNote: It’s good to keep in mind the scale of the x axis when\r\nreading Plot A, as small numbers suggest these factors don’t explain\r\nmuch of the overall variation in our data. A posterior weight of ~0.004\r\nsuggests that airports explain some variation, but not very much, of\r\nDelma observations.\r\n\r\n\r\nplot(model_bias_delma)\r\n\r\n\r\n\r\nYou can also use summary() to view the model’s summary\r\nstatistics.\r\n\r\n\r\nsummary(model_bias_delma)\r\n\r\nNumber of occurences:  1900 \r\nRaster resolution:  0.05 \r\nConvexhull:  \r\nGeographic extent:\r\nclass      : Extent \r\nxmin       : 129.03 \r\nxmax       : 137.98 \r\nymin       : -26.02 \r\nymax       : -11.02 \r\nBias weights:\r\n            bias_weight      std_dev\r\nw_airports 4.212005e-03 1.657795e-04\r\nw_cities   2.926758e-04 1.817098e-04\r\nw_rivers   4.331625e-04 8.453850e-05\r\nw_roads    1.903174e-03 3.787051e-04\r\nhp_rate    6.438165e+02 2.931110e+02\r\n\r\nMap the bias\r\nBefore viewing the mapped output from {sampbias}, it\r\nwould be useful to see where the airports, cities, roads and rivers are.\r\nObservations of Delma are in orange.\r\n\r\nExpand for code to create map\r\n\r\n\r\n# Load in data for landscape features\r\ndata(airports)\r\ndata(waterbodies)\r\ndata(cities)\r\ndata(roads)\r\n\r\n\r\n# Combine data\r\nfeatures <- c(airports, cities, waterbodies, roads)\r\n\r\n# Convert to spatial features, set coordinate system, filter to within NT\r\n# Add feature ID to each for plotting\r\nfeatures_sf <- features |>\r\n  set_names(c(\"Airport\", \"City\", \"River\", \"Road\")) |>\r\n  map_dfr(~ st_as_sf(.) |> \r\n            st_set_crs(st_crs(\"WGS84\")) |>\r\n            st_intersection(nt_wgs84),\r\n          .id = \"feature\")\r\n\r\n\r\n# Plot all the points on a map alongside the features\r\nfeatures_map <- ggplot() +\r\n  # NT map\r\n  geom_sf(data = nt_wgs84,\r\n          fill = \"grey98\", color = \"grey40\") +\r\n  # Rivers & Roads\r\n  geom_sf(data = features_sf |> filter(feature == \"River\" | feature == \"Road\"),\r\n          mapping = aes(color = feature),\r\n          size = 1.1,\r\n          show.legend = \"line\") +\r\n  # Airports\r\n  geom_sf(data = features_sf |> filter(feature == \"Airport\" ),\r\n          mapping = aes(color = feature),\r\n          shape = 17,\r\n          size = 6,\r\n          show.legend = \"point\") +\r\n  # Cities\r\n  geom_sf(data = features_sf |> filter(feature == \"City\"),\r\n          mapping = aes(color = feature),\r\n          shape = 16,\r\n          size = 4,\r\n          show.legend = \"point\") +\r\n  # Observations\r\n  geom_point(data = delma_records_filtered,\r\n             mapping = aes(x = decimalLongitude, y = decimalLatitude),\r\n             color = \"#E06E53\",\r\n             size = 1.1,\r\n             alpha = 0.3) +\r\n  # Specify colours\r\n  scale_color_manual(values = c(\r\n    \"River\" = \"#249db5\",\r\n    \"Road\" = \"#ffc517\",\r\n    \"Airport\" = \"#9956db\",\r\n    \"City\" = \"#30c788\"\r\n  ),\r\n  # Create custom line/point legend\r\n  guide = guide_legend(\r\n    override.aes = list(linetype = c(\"solid\", \"solid\", \"blank\", \"blank\"), \r\n                        shape = c(NA, NA, 17, 16),\r\n                        size = c(1.1, 1.1, 6, 4)),\r\n    title = NULL)) +\r\n  theme_void() +\r\n  theme(legend.position = \"bottom\")\r\n\r\n\r\n\r\n\r\n\r\nYou can use the map_bias() function to see the projected\r\neffect of bias on Delma records.\r\nThe map_bias() function has several types of outputs\r\nthat you can experiment with (e.g. diff_to_max,\r\nsampling_rate, log_sampling_rate). In our\r\ncase, because the difference in record numbers is quite large between\r\nlocations with lots of records and locations with few, the\r\nlog_sampling_rate plot gives a more balanced view of where\r\nobservations are missing.\r\nFirst, you’ll notice that the highest sampling rates centre around\r\nairports, highlighted in bright yellow and green. You will also notice a\r\ndark blue line between the two major NT airports, showing a somewhat\r\nsurprisingly clear spatial gap in observations of Delma between\r\nthe two major Northern Territory airports! Even accounting for roads,\r\nrivers and cities does little to erase this dark blue line.\r\n\r\n\r\n# Project the bias effect in space\r\ndelma <- sampbias::project_bias(model_bias_delma)\r\n\r\n# Map\r\nsampbias::map_bias(delma, type=\"log_sampling_rate\")\r\n\r\n\r\n\r\nOther species\r\nWhat about other species? Here are a few I have selected for\r\ncomparison.\r\nSelect each tab to view their results.\r\n\r\n\r\n\r\n\r\nQuolls\r\nQuolls & Mulgaras\r\n\r\n\r\n\r\nFigure 2: Left: Dasyurus\r\nhallucatus (David White CC BY-NC 4.0), Right: Dasycercus\r\nblythi (Robert Browne-Cooper CC-BY-NC 3.0 (Au))\r\n\r\n\r\n\r\n\r\n\r\n\r\nLittle Kingfisher\r\nLittle Kingfisher\r\n\r\n\r\n\r\nFigure 3: Left: Ceyx\r\npusillus (Greg Holland CC BY-NC 4.0), Right: Ceyx\r\npusillus (Graham Winterflood CC-BY-SA 4.0 (Au))\r\n\r\n\r\n\r\n\r\n\r\n\r\nMantids\r\nMantids\r\n\r\n\r\n\r\nFigure 4: Left: Hierodula\r\nmajuscula (Michael Mcmaster CC BY-NC 4.0), Right: Tenodera\r\naustralasiae (Reiner Richter CC BY-NC-SA 4.0))\r\n\r\n\r\n\r\n\r\n\r\n\r\nGreen birdflower\r\nGreen birdflower\r\n\r\n\r\n\r\nFigure 5: Left: Crotalaria\r\ncunninghamii (Gerald Krygsman CC BY-NC 4.0), Right: Crotalaria\r\ncunninghamii (Steve Dew CC BY-NC 4.0))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFinal thoughts\r\nThe {sampbias} package offers a cool, simple way to\r\nunderstand spatial biases in species observations. Research has found\r\nthese data biases are very common across taxa, with\r\nan estimated 90% of global observations recorded within 2.5 km of a road\r\n(Hughes et al. 2021)! So, it is worth considering this when\r\ninterpreting any data on species distributions.\r\nSpatial biases aren’t the only ones that affect observations either.\r\nThere are potential taxonomic, temporal and environmental biases that\r\ncan influence them, too. You might find other R packages like the {ocuAccess}\r\npackage more useful if you are interested in calculating the effects\r\nof other types of biases on your data.\r\nWe hope you’ll be able to use {sampbias} in your own\r\nanalyses so you can check yourself1 before you wreck\r\nyourself2!\r\n\r\nExpand for session info\r\n\r\n─ Session info ─────────────────────────────────────────────────────\r\n setting  value\r\n version  R version 4.2.1 (2022-06-23 ucrt)\r\n os       Windows 10 x64 (build 19044)\r\n system   x86_64, mingw32\r\n ui       RStudio\r\n language (EN)\r\n collate  English_Australia.utf8\r\n ctype    English_Australia.utf8\r\n tz       Australia/Sydney\r\n date     2022-08-09\r\n rstudio  2022.07.1+554 Spotted Wakerobin (desktop)\r\n pandoc   2.18 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\r\n\r\n─ Packages ─────────────────────────────────────────────────────────\r\n package     * version date (UTC) lib source\r\n data.table  * 1.14.2  2021-09-27 [1] CRAN (R 4.2.1)\r\n data.tree   * 1.0.0   2020-08-03 [1] CRAN (R 4.2.1)\r\n dplyr       * 1.0.9   2022-04-28 [1] CRAN (R 4.2.1)\r\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.2.1)\r\n galah       * 1.4.0   2022-01-24 [1] CRAN (R 4.2.1)\r\n ggplot2     * 3.3.6   2022-05-03 [1] CRAN (R 4.2.1)\r\n ggraph      * 2.0.6   2022-08-08 [1] CRAN (R 4.2.1)\r\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.2.1)\r\n htmltools   * 0.5.2   2021-08-25 [1] CRAN (R 4.2.1)\r\n htmlwidgets * 1.5.4   2021-09-08 [1] CRAN (R 4.2.1)\r\n kableExtra  * 1.3.4   2021-02-20 [1] CRAN (R 4.2.1)\r\n metathis    * 1.1.1   2021-06-29 [1] CRAN (R 4.2.1)\r\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.2.1)\r\n parameters  * 0.18.1  2022-05-29 [1] CRAN (R 4.2.1)\r\n plotly      * 4.10.0  2021-10-09 [1] CRAN (R 4.2.1)\r\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.2.1)\r\n readr       * 2.1.2   2022-01-30 [1] CRAN (R 4.2.1)\r\n rgeos       * 0.5-9   2021-12-15 [1] CRAN (R 4.2.1)\r\n rmarkdown   * 2.14    2022-04-25 [1] CRAN (R 4.2.1)\r\n sampbias    * 1.0.4   2022-07-07 [1] Github (azizka/sampbias@b1d951b)\r\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.2.1)\r\n sf          * 1.0-7   2022-03-07 [1] CRAN (R 4.2.0)\r\n sp          * 1.5-0   2022-06-05 [1] CRAN (R 4.2.1)\r\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.2.1)\r\n tibble      * 3.1.7   2022-05-03 [1] CRAN (R 4.2.1)\r\n tidygraph   * 1.2.1   2022-04-05 [1] CRAN (R 4.2.1)\r\n tidyr       * 1.2.0   2022-02-01 [1] CRAN (R 4.2.1)\r\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.2.1)\r\n viridis     * 0.6.2   2021-10-13 [1] CRAN (R 4.2.1)\r\n viridisLite * 0.4.0   2021-04-13 [1] CRAN (R 4.2.1)\r\n\r\n [1] C:/Users/KEL329/R-packages\r\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.2.1/library\r\n\r\n────────────────────────────────────────────────────────────────────\r\n\r\n\r\nfor biases↩︎\r\nfrom over-interpreting your data↩︎\r\n",
    "preview": "posts/2022-07-22_sample-bias/distill-preview.png",
    "last_modified": "2022-08-09T12:28:27+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-05-23-ggnewscale/",
    "title": "Multiple colour scales in choropleth maps with {ggnewscale}",
    "description": "Using multiple colour scales can be a great way to visually differentiate between geographic categories on a map. Here, we demonstrate this by creating a choropleth map to represent the density of plant records from the ALA across bioregions in Australia, and add multiple colour scales to differentiate marine and terrestrial records",
    "author": [
      {
        "name": "Shandiya Balasubramaniam",
        "url": {}
      }
    ],
    "date": "2022-05-31",
    "categories": [
      "Eukaryota",
      "Plantae",
      "Chlorophyta",
      "Maps"
    ],
    "contents": "\r\n\r\nContents\r\nGet geospatial and count\r\ndata\r\nJoin geospatial and count\r\ndata\r\nMake a map\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nShandiya\r\nBalasubramaniam\r\n\r\n\r\nDate:\r\n\r\n31 May, 2022\r\n\r\n\r\n\r\n\r\n\r\nChoropleth maps visually summarise how variables (like species\r\nrichness or population density, for example) vary across geographic\r\nareas. These maps require two inputs:\r\na geospatial object with information on regional boundaries\r\na numerical variable that can be mapped to each geographic unit\r\nusing colour\r\nHere, I walk through the process of mapping the density of plant\r\nrecords from the ALA to geographic bioregions across Australia, using\r\ntwo colour scales to differentiate between marine and terrestrial\r\nrecords.\r\nGet geospatial and count\r\ndata\r\nLet’s start by loading the packages we’ll need.\r\n\r\n\r\nlibrary(galah)\r\nlibrary(here)\r\nlibrary(sf)\r\nlibrary(rmapshaper)\r\nlibrary(dplyr)\r\nlibrary(stringr)\r\nlibrary(ggplot2)\r\nlibrary(ggnewscale)\r\n\r\n\r\n\r\nNext, we’ll need some regional boundaries. I think the IBRA7\r\nand IMCRA4\r\nbioregions will work nicely for what we’re planning. These boundaries\r\nclassify Australia’s landscapes and waters into geographically distinct\r\nbioregions based on variables like climate, geomorphology, and species\r\ninformation.\r\nAfter downloading the data, we can read it in using the sf package and\r\ncheck that it looks correct. Here, I’ve also elected to use\r\nms_simplify() from the rmapshaper\r\npackage to simplify the geospatial features and speed up\r\ncomputation.\r\n\r\n\r\n# read in IMCRA shapefile\r\nimcra_shp <- st_read(here(\"_posts\", \r\n                          \"data\",\r\n                          \"imcra_mesoscale_bioregions\",\r\n                          \"imcra4_meso.shp\"), \r\n                     quiet = TRUE) |> \r\n  ms_simplify(keep = 0.1)\r\n\r\n# read in IBRA shapefile\r\nibra_shp <- st_read(here(\"_posts\",\r\n                         \"data\",\r\n                         \"IBRA7_regions\",\r\n                         \"ibra7_regions.shp\"),\r\n                    quiet = TRUE) |> \r\n  ms_simplify(keep = 0.1)\r\n\r\n\r\n\r\nAnd finally, let’s get the number of plant records in the ALA using\r\nthe galah\r\npackage, grouped by IBRA or IMCRA region. To do this, we need to\r\nknow what the ALA calls the IBRA and IMCRA layers.\r\nUsing the search_fields() function, we can determine\r\nthat the IBRA layer we’re after is called cl1048 and\r\nthe IMCRA layer, cl966.\r\n\r\n\r\nsearch_fields(\"IBRA\")\r\n\r\n\r\n# A tibble: 5 x 4\r\n  id     description                                       type  link \r\n  <chr>  <chr>                                             <chr> <chr>\r\n1 cl914  \"IBRA 6 Sub Regions IBRA 6 sub regions\"           laye~ \"htt~\r\n2 cl3    \"Western Australian Biodiversity Science Researc~ laye~ \"htt~\r\n3 cl20   \"IBRA 6 Regions Interim Biogeographic Regionalis~ laye~ \"htt~\r\n4 cl1049 \"IBRA 7 Subregions IBRA 7 Subregions\"             laye~ \"htt~\r\n5 cl1048 \"IBRA 7 Regions Interim Biogeographic Regionalis~ laye~ \"htt~\r\n\r\nsearch_fields(\"IMCRA\")\r\n\r\n\r\n# A tibble: 2 x 4\r\n  id    description                                        type  link \r\n  <chr> <chr>                                              <chr> <chr>\r\n1 cl966 IMCRA Meso-scale Bioregions IMCRA Meso-scale Bior~ laye~ http~\r\n2 cl21  IMCRA 4 Regions Integrated Marine and Coastal Reg~ laye~ http~\r\n\r\nTo get counts of records from the ALA, we can pass a query with\r\ngalah_call() and build our query using pipes.\r\nWe will specify that we only want plant records matching\r\nPlantae or Chlorophyta using\r\ngalah_identify(), apply the default set of ALA data quality\r\nfilters to remove poor quality records using\r\ngalah_filter(), group records by region using\r\ngalah_group_by(), and finally return the counts of records\r\nthat match all our criteria with atlas_counts().\r\n\r\n\r\n# counts in IBRA regions\r\nibra_counts <- galah_call() |>\r\n  galah_identify(\"plantae\", \"chlorophyta\") |>\r\n  galah_filter(profile = \"ALA\") |> \r\n  galah_group_by(\"cl1048\") |>      # IBRA regions\r\n  atlas_counts()\r\n\r\nhead(ibra_counts)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  cl1048                      count\r\n  <chr>                       <int>\r\n1 Sydney Basin              2249452\r\n2 South Eastern Highlands   1408493\r\n3 South East Corner          993627\r\n4 NSW North Coast            764686\r\n5 South Eastern Queensland   705821\r\n6 Murray Darling Depression  696545\r\n\r\n# counts in IMCRA regions\r\nimcra_counts <- galah_call() |>\r\n  galah_identify(\"plantae\", \"chlorophyta\") |>\r\n  galah_filter(profile = \"ALA\") |> \r\n  galah_group_by(\"cl966\") |>      # IMCRA bioregions\r\n  atlas_counts()\r\n\r\nhead(imcra_counts)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  cl966                count\r\n  <chr>                <int>\r\n1 Victorian Embayments 23173\r\n2 Shoalwater Coast     19276\r\n3 Lucinda-Mackay Coast 18426\r\n4 Bruny                18355\r\n5 Flinders             17530\r\n6 Central Victoria     17413\r\n\r\nJoin geospatial and count\r\ndata\r\nWe now have the two things we need to make a choropleth map:\r\nIBRA/IMCRA boundaries\r\ncounts of plant records in each region\r\nTo create a plot, we need to combine the geospatial and numeric data.\r\nBut first, let’s check if the data needs to be tidied.\r\nAs we’re going to be joining the spatial and count data, we need to\r\nbe sure that the names of the IBRA/IMCRA regions match in both datasets.\r\nTo double check that all of our region names match, we’ll use\r\nsetdiff(). There are no name mismatches when\r\ncharacter(0) is returned, but if any region names are\r\nreturned that means there is a problem somewhere that we need to fix\r\nbefore joining our dataframes.\r\nWhen we run setdiff(), the IBRA names match perfectly,\r\nbut there’s a mismatch in two IMCRA names.\r\n\r\n\r\n# check region names match\r\nsetdiff(ibra_counts$cl1048, ibra_shp$REG_NAME_7)\r\n\r\n\r\ncharacter(0)\r\n\r\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\r\n\r\n\r\n[1] \"Pilbarra (nearshore)\" \"Pilbarra (offshore)\" \r\n\r\nReversing the order of IMCRA data frames in setdiff()\r\nreveals that that Pilbara is misspelled in the\r\nimcra_counts dataset. We can easily change this and confirm\r\nboth sets of names match before continuing.\r\n\r\n\r\n# check the reverse for IMCRA names\r\nsetdiff(imcra_shp$MESO_NAME, imcra_counts$cl966)\r\n\r\n\r\n[1] \"Pilbara (offshore)\"  \"Pilbara (nearshore)\"\r\n\r\n# replace \"Pilbarra\" with \"Pilbara\" \r\nimcra_counts <- imcra_counts |> \r\n  mutate(cl966 = str_replace(string = cl966, \r\n                             pattern = \"Pilbarra\", \r\n                             replacement = \"Pilbara\"))\r\n\r\n# check names match\r\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\r\n\r\n\r\ncharacter(0)\r\n\r\nNow let’s check how our data are distributed so we can decide whether\r\nwe should scale them with a transformation before plotting. Data skewed\r\ntoo far to the right will not show differences very clearly when they\r\nare mapped.\r\nChecking the distribution of counts in each dataset shows a\r\nsubstantial skew to the right.\r\n\r\n\r\nhist(imcra_counts$count)\r\nhist(ibra_counts$count)\r\n\r\n\r\n\r\n\r\nApplying a log-transformation to the count data makes the\r\ndistribution more symmetrical.\r\n\r\n\r\nhist(log(imcra_counts$count))\r\nhist(log(ibra_counts$count))\r\n\r\n\r\n\r\n\r\nNext, we join the geospatial and numeric data. Along the way, we\r\nrename some columns, remove unnecessary columns, calculate counts as a\r\nproportion of the area of each region (so we’re plotting density of\r\nrecords, not counts of records), and convert the resulting dataframe\r\ninto a simple features object.\r\n\r\n\r\nimcra_join <- imcra_counts |> \r\n  full_join(y = imcra_shp, by = c(\"cl966\" = \"MESO_NAME\")) |> \r\n  rename(\"imcra\" = \"cl966\") |> \r\n  select(imcra, count, AREA_KM2, geometry) |> \r\n  mutate(density_log10 = log10(count / AREA_KM2)) |> \r\n  select(imcra, density_log10, geometry) |> \r\n  st_as_sf()\r\n\r\nibra_join <- ibra_counts |> \r\n  full_join(y = ibra_shp, by = c(\"cl1048\" = \"REG_NAME_7\")) |> \r\n  rename(\"ibra\" = \"cl1048\") |> \r\n  select(ibra, count, SQ_KM, geometry) |> \r\n  mutate(density_log10 = log10(count / SQ_KM)) |> \r\n  select(ibra, density_log10, geometry) |> \r\n  st_as_sf()\r\n\r\n\r\n\r\nMake a map\r\nFinally, we’ll use the ggnewscale\r\npackage to apply different colour palettes to the marine and\r\nterrestrial data in a choropleth map.\r\n\r\n\r\nggplot() + \r\n  geom_sf(data = imcra_join,\r\n          aes(fill = density_log10),\r\n          colour = NA) +\r\n  scale_fill_distiller(name = \"IMCRA\",\r\n                       type = \"seq\",\r\n                       palette = \"BuPu\",\r\n                       direction = 1,\r\n                       labels = c(\"0.001\", \"0.01\", \"0.1\", \"1\", \"10\"),\r\n                       guide = guide_colorsteps(direction = \"horizontal\",\r\n                                                label.position = \"bottom\",\r\n                                                title.position = \"left\")) +\r\n  # adds new colour scale\r\n  ggnewscale::new_scale_fill() +\r\n  geom_sf(data = ibra_join,\r\n          aes(fill = density_log10),\r\n          colour = NA) +\r\n  scale_fill_distiller(name = \"IBRA\",\r\n                       type = \"seq\",\r\n                       palette = \"YlOrBr\",\r\n                       direction = 1,\r\n                       labels = c(\"0.1\", \"1\", \"10\", \"100\"),\r\n                       guide = guide_colorsteps(direction = \"horizontal\",\r\n                                                label.position = \"bottom\",\r\n                                                title.position = \"left\")) +\r\n  # adds a title for both legends\r\n  annotate(\"text\", \r\n           x = 133, \r\n           y = -45.5, \r\n           label = \"No. of records per square km\",\r\n           size = 6) +\r\n  coord_sf(xlim = c(110, 155), ylim = c(-45, -10)) +\r\n  theme_void() +\r\n  theme(legend.position = \"bottom\",\r\n        legend.key.width = unit(12, 'mm'))\r\n\r\n\r\n\r\n\r\n\r\n\r\nSuccess!\r\nOne thing to note is that we didn’t necessarily have to use\r\nggnewscale here; we could just as easily have combined all\r\nthe data and plotted them on the same map without keeping the IBRA and\r\nIMCRA datasets separate. But, i) it’s nice to be able to differentiate\r\nmarine and terrestrial regions at a glance, and ii) using two legends\r\nalso makes it clear that there’s a stark difference in the number of\r\nplant records for marine and terrestrial regions.\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/dataviz/choropleth_ggnewscale.png",
    "last_modified": "2022-05-31T16:29:30+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-05-17_3d-map/",
    "title": "Download plant species data by hexagon to make a 3D hex map\n",
    "description": "Making plots eye-catching can be useful for science communication. Here, we \nshow how to make 3D plots in R with the `rayshader` package by visualising the \nnumber of species identified from ALA observations since 2020",
    "author": [
      {
        "name": "Dax Kellie",
        "url": {}
      }
    ],
    "date": "2022-05-23",
    "categories": [
      "Eukaryota",
      "Plantae",
      "Maps"
    ],
    "contents": "\r\n\r\nContents\r\nMake a hexagon map\r\nDownload species data\r\nPlot number of species\r\nRender in 3D\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nDax\r\nKellie\r\n\r\n\r\nDate:\r\n\r\n23 May, 2022\r\n\r\n\r\n\r\n\r\n\r\nGrabbing people’s attention in a content-filled world can be\r\ndifficult. 3D maps can be particularly eye-catching, and thanks to the\r\nrayshader package\r\nit has become relatively simple to make a beautiful 3D plot from a plot\r\nmade with ggplot2.\r\nIn this post, we’ll make a 3D hex map of the number of plant species\r\nidentified from ALA observations since 2020. This map builds on a previous\r\nhex map post, but this time we will use a more unique “grid-to-data”\r\nmethod to download our data, where instead of plotting hexagons over our\r\nmap after extracting data, we’ll create a grid of hexagons that\r\nmap to Australia before extracting any data and query the ALA\r\nfor data for each hexagon. This method is cool because it saves\r\na lot of work wrangling your data to fit your plot later on.\r\nMake a hexagon map\r\nFirst let’s download the necessary packages\r\n\r\n\r\n# packages\r\nlibrary(galah)      # To download species data\r\nlibrary(rayshader)  # For 3d rendering\r\nlibrary(tidyverse)  # Data wrangling\r\nlibrary(here)       # Safe paths\r\nlibrary(sf)         # Spatial features\r\nlibrary(ozmaps)     # For map of oz\r\n\r\n\r\n\r\nNow let’s get a map of Australia from the ozmaps\r\npackage\r\n\r\n\r\n# get a map and project to WGS84\r\noz_wgs84 <- ozmap_data(data = \"country\") |>\r\n  st_transform(crs = st_crs(\"WGS84\"))\r\n\r\n## check map\r\nggplot(oz_wgs84) + geom_sf()\r\n\r\n\r\n\r\n\r\nNext let’s create our grid of hexagons and do some tidying to make\r\nsure the hexagons are only over the land\r\n\r\n\r\n# create grid\r\noz_grid <- st_make_grid(oz_wgs84,\r\n                        what = \"polygons\",\r\n                        cellsize = 1.0,\r\n                        square = FALSE,\r\n                        flat_topped = TRUE)\r\n\r\n# subset to grid cells that are within land\r\nkeep_hexes <- st_intersects(oz_grid, oz_wgs84)\r\nkeep_hexes <- as.data.frame(keep_hexes)$row.id\r\noz_grid <- oz_grid[keep_hexes]\r\n\r\n\r\n\r\nIf we plot our new oz_grid over our map, we can see how\r\nthe hexagons fill our map of Australia\r\n\r\n\r\n## check\r\nggplot() +\r\n  geom_sf(data = oz_wgs84) +\r\n  geom_sf(data = oz_grid, fill = NA, color = \"red\")\r\n\r\n\r\n\r\n\r\nDownload species data\r\nNow that we have our grid of hexagons, we can download data from the\r\nALA using the galah\r\npackage. Rather than downloading all data on the number of species\r\nidentified since 2020 and then plotting the data as hexagons, we will\r\nmake a function that sends individual queries to return the number of\r\nspecies identified within each hexagon.\r\nOur function get_counts() works in 3 parts:\r\nThe first part does some necessary editing of each Well Known\r\nText (WKT) string so that they are compatible with\r\ngalah.\r\nThe second part builds a query to download ALA data, beginning\r\nwith galah_call(). We add the WKT for each hexagon to our\r\nquery with galah_geolocate(), specify that we want to\r\nreturn only Plantae and Chlorophyta species with\r\ngalah_identify(), and filter to only records from 2020\r\nonwards with galah_filter(). We’ll also add\r\ngalah_filter(profile = \"ALA\") to use a standard ALA data\r\nquality filter (known in the ALA as as a data “profile”). We end our\r\nquery with atlas_counts(type = \"species\") to return counts\r\nof species, rather than counts of records (which is the default\r\nsetting).\r\nThe final part makes sure that if any hexagons have 0 species\r\nidentified, they will return a 0 rather than an NA, which\r\ntriggers an error in R.\r\n\r\n\r\nget_counts <- function(hexagon){\r\n  \r\n    # convert to wkt\r\n    wkt_string <- st_as_text(oz_grid[[hexagon]]) %>%\r\n      sub(\")))\", \"))\", .) %>%\r\n      sub(\"POLYGON \", \"POLYGON\", .)\r\n    \r\n    # get counts\r\n    result <- galah_call() |>\r\n      galah_geolocate(wkt_string) |>\r\n      galah_identify(\"plantae\", \"chlorophyta\") |>\r\n      galah_filter(profile = \"ALA\",\r\n                   decimalLongitude > 110,\r\n                   year >= 2020) |>\r\n      atlas_counts(type = \"species\", # get species counts\r\n                   limit = NULL)\r\n    \r\n    # light formatting to catch errors\r\n    if(is.null(result)){\r\n      tibble(count = NA, id = hexagon)\r\n    }else{\r\n      result$id <- hexagon\r\n      result\r\n    }\r\n  }\r\n\r\n\r\n\r\nWe can use purrr::map() to run this function recursively\r\nfor each hexagon. Then we can bind the separate lists into one\r\ndata.frame with purrr::map_dfr(). As oz_grid\r\nis a spatial object containing POLYGONs (which R treats\r\nslightly differently to a data.frame), we have to use\r\nseq_along(oz_grid) to enable us to run the function for\r\neach line, which corresponds to each POLYGON.\r\nIMPORTANT NOTE: This function will send\r\nlots of queries all at once to the ALA, so it is best\r\nto use restraint on how many times you run it because it can take a long\r\ntime and, if run many times in a row, can make it take even longer.\r\n\r\n\r\n# download number of species for each polygon\r\ncounts_list <- map(seq_along(oz_grid), get_counts)\r\n\r\n# bind lists to data frame\r\ncounts_df <- map_dfr(counts_list, rbind)\r\n\r\n\r\n\r\ncounts_df now contains a single count of species for\r\neach hexagon, indicated by a unique id\r\n\r\n\r\nhead(counts_df, 10L)\r\n\r\n\r\n# A tibble: 10 x 2\r\n   count    id\r\n   <dbl> <int>\r\n 1   396     1\r\n 2   303     2\r\n 3   457     3\r\n 4   178     4\r\n 5  1025     5\r\n 6   442     6\r\n 7   507     7\r\n 8   438     8\r\n 9   592     9\r\n10     5    10\r\n\r\nNow let’s merge our species counts in counts_df to our\r\noz_grid hexagons so we can plot them. To do so, we’ll\r\nconvert oz_grid to a tibble called oz_df, add\r\na blank count column, and fill that column with the species\r\ncounts in counts_df for each hexagon by\r\nid.\r\n\r\n\r\n# convert to tibble, attach counts\r\noz_df <- st_as_sf(oz_grid)\r\noz_df$count <- NA\r\noz_df$count[counts_df$id] <- counts_df$count\r\n\r\n\r\n\r\nLet’s see the final result by checking the hexagons with highest\r\nspecies counts\r\n\r\n\r\n# See top hexagons\r\noz_df %>%\r\n  arrange(desc(count)) %>%\r\n  head(10L)\r\n\r\n\r\nSimple feature collection with 10 features and 1 field\r\nGeometry type: POLYGON\r\nDimension:     XY\r\nBounding box:  xmin: 137.8823 ymin: -38.63203 xmax: 153.7594 ymax: -26.63203\r\nGeodetic CRS:  WGS 84\r\n   count                              x\r\n1   2543 POLYGON ((150.0066 -33.6320...\r\n2   2144 POLYGON ((150.8726 -34.1320...\r\n3   2073 POLYGON ((144.8105 -37.6320...\r\n4   2005 POLYGON ((150.0066 -34.6320...\r\n5   1959 POLYGON ((152.6047 -27.1320...\r\n6   1949 POLYGON ((152.6047 -28.1320...\r\n7   1804 POLYGON ((150.8726 -33.1320...\r\n8   1616 POLYGON ((151.7387 -27.6320...\r\n9   1604 POLYGON ((137.8823 -34.6320...\r\n10  1577 POLYGON ((143.9444 -38.1320...\r\n\r\nPlot number of species\r\nThe first step to making our 3D map is to make a 2D map with\r\nggplot2. I have set the fill of our map to use\r\noz_df’s count column and log transformed it to\r\nmake our final scale easier to read. The\r\nscale_fill_distiller() function has a nice “Greens” palette\r\nto make our plant species data look extra planty, and I have added\r\ncustom limits and labels to make sure the scale is understandable.\r\n\r\n\r\nhex_map <- ggplot() +\r\n  geom_sf(\r\n    data = oz_df,\r\n    mapping = aes(fill = log10(count + 1)), # log10 + 1 transformed\r\n    alpha = 1,\r\n    color = NA) +\r\n  scale_fill_distiller(name = \"Number of species \\n(since 1 Jan, 2020)\",\r\n                       type = \"seq\",\r\n                       direction = 1,\r\n                       limits = c(0,4),\r\n                       labels = c(\"10\", \"100\", \"1,000\"),\r\n                       palette = \"Greens\",\r\n                       # edit legend to be horizontal-bottom\r\n                       guide = guide_colorsteps(direction = \"horizontal\",\r\n                                                label.position = \"top\",\r\n                                                title.position = \"bottom\",\r\n                                                title.hjust = 0.5)\r\n                       ) +\r\n  # add map\r\n  geom_sf(data = oz_wgs84,\r\n          color = NA,\r\n          fill = NA)  +\r\n  # crop map\r\n  coord_sf(xlim = c(110, 155), \r\n           ylim = c(-45, -10)) +\r\n  # Adjust text and make aesthetic more minimal\r\n  theme(title = element_text(face = \"bold\"),\r\n        legend.title = element_text(size = 19),\r\n        legend.position = \"bottom\",\r\n        legend.key.width = unit(28, 'mm'),\r\n        legend.text = element_text(size = 16),\r\n        plot.background = element_rect(fill = 'white', colour = 'white'),\r\n        panel.background = element_rect(fill = 'white', colour = 'white'),\r\n        axis.title = element_blank()\r\n        )\r\n\r\nhex_map\r\n\r\n\r\n\r\n\r\nRender in 3D\r\nIt’s time to get 3-Dimensional! Using\r\nrayshader::plot_gg(), we can render a nice 3d version of\r\nour plot1\r\n\r\n\r\n# Render 3d plot\r\nplot_gg(hex_map, \r\n        width = 9, \r\n        height = 8,\r\n        scale = 300, # adjust height of 3D transformation\r\n        windowsize = c(1200, 960), # adjust window of rendered plot\r\n        fov = 75,    # adjust size/strength of blur around outer edges\r\n        zoom = 0.37, \r\n        theta = 320, # adjust left-right rotation of view\r\n        phi = 33)    # adjust height of view\r\n\r\n\r\n\r\n\r\n\r\n\r\nLooks great! Finally, we can save our plot using\r\nrender_snapshot()\r\n\r\n\r\n# save\r\nSys.sleep(0.2)\r\nrender_snapshot(here(\"folder\", \"subfolder\", \"3d-map.png\"))\r\n\r\n\r\n\r\nIn this case, a 3D map makes the areas with many and few species very\r\nnoticeable, which is a useful message to communicate.\r\nHowever, in general, one should be careful about using 3D plots\r\nwithout first considering the main messages they want people to take\r\naway from their data, and whether a 3D figure communicates this better\r\nthan a 2D alternative. People aren’t as good at quickly interpreting\r\ndifferences in height, shape or location in 3D plots compared to 2D\r\nplots. One reason for this weakness is that most 3D plots can only be\r\nviewed from a single angle. Depending on what angle the view point of\r\nthe plot is set to, the literal differences in heights or locations\r\nbetween shapes might change, even if their actual differences in the\r\ndata they represent don’t change. Looking at a 3D map from above, in the\r\nmiddle, or below changes how the shapes appear, and sometimes they may\r\nnot accurately represent the true differences between things\r\nyou want to compare in your plot. This quirk of 3D plots makes it easier\r\nfor people to misinterpret your plot and, as a result, take away the\r\nwrong message from the data (this idea is known as the principle\r\nof proportional ink (Tufte, 1983).\r\nCarl Bergstrom has written an\r\nexcellent explanation of why this principle matters in data\r\nvisualisation)\r\nEven so, 3D plots can be a beautiful way to see the number of plant\r\nspecies identified in the ALA since 2020. Even cooler, querying species\r\ndata from the ALA for each hexagon in our map with galah\r\ncan be an efficient way to download data and reduce data wrangling work\r\nlater on!\r\n\r\nIf you get a weird error related to\r\nthe scales package, updating to the latest version should\r\nfix it: https://github.com/tylermorganwall/rayshader/issues/181#:~:text=Update%20to%20the,install.packages(%27rayshader%27)\r\n↩︎\r\n",
    "preview": "https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/dataviz/plants_hex-map.png",
    "last_modified": "2022-05-25T17:13:42+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-14_hex-maps-for-species-occurrence-data/",
    "title": "Hex maps for species occurrence data",
    "description": "Hex maps are a neat way to represent spatial information. Here, we \nshow how to draw one using the most common species in the ALA database: \nthe iconic Australian Magpie.",
    "author": [
      {
        "name": "Matilda Stevenson",
        "url": {}
      }
    ],
    "date": "2022-02-25",
    "categories": [
      "Maps",
      "Eukaryota",
      "Animalia",
      "Chordata",
      "Aves"
    ],
    "contents": "\r\n\r\nContents\r\nGetting species occurrences\r\nPlotting binned data\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMatilda Stevenson, Martin Westgate, Dax Kellie\r\n\r\n\r\nDate:\r\n\r\n25 February, 2022\r\n\r\n\r\n\r\n\r\n\r\nThe Atlas of Living Australia (ALA) holds records of magpie sightings from a number data providers like iNaturalist, eBird and BirdLife Australia. Let’s make a visualisation of Australian Bird of the Year 2018 winner, Magpies, using records held in the ALA.\r\nGetting species occurrences\r\nAs with any R project, a good first step is to load the required packages\r\n\r\n\r\n# packages\r\nlibrary(ggplot2)\r\nlibrary(tidyr)\r\nlibrary(dplyr)\r\nlibrary(ozmaps)\r\nlibrary(sf)\r\nlibrary(hexbin)\r\n\r\n\r\n\r\nWe will use the {galah} package to download records.\r\nTo download species occurrence records, the {galah} package requires you to add an email registered with the ALA to galah_config(). If running this code yourself, you will need to add an email using the code below, substituting your email with myemail@email.com. This email address should be registered with the ALA, which you can do here\r\n\r\n\r\nlibrary(galah)\r\ngalah_config(email = \"myemail@email.com\")\r\n\r\n\r\n\r\nNow we can download magpie occurrence records by using atlas_occurrences(). Note that we also set our data ‘profile’ to ‘ALA’; this means we only download records that meet some basic data quality standards enforced by the atlas. This is optional, but tends to improve the quality of the data returned. (If you wish to see the data quality filters applied in the ALA profile, use search_profile_attributes(\"ALA\"))\r\n\r\n\r\nmagpie_occ <- galah_call() %>%\r\n  galah_identify(\"Cracticus tibicen\") %>%\r\n  galah_filter(profile = \"ALA\") %>%\r\n  atlas_occurrences()\r\n\r\n\r\n\r\nLet’s have a look at the first few rows of the data we’ve just downloaded:\r\n\r\n\r\nmagpie_occ %>% head()\r\n\r\n\r\n# A tibble: 6 x 7\r\n  decimalLatitude decimalLongitude eventDate            scientificName\r\n            <dbl>            <dbl> <chr>                <chr>         \r\n1           -45.0             169. \"\"                   Gymnorhina ti~\r\n2           -44.5             170. \"2018-10-27T21:44:0~ Gymnorhina ti~\r\n3           -44.1             170. \"2019-05-02T05:18:0~ Gymnorhina ti~\r\n4           -43.6             147. \"\"                   Gymnorhina ti~\r\n5           -43.6             147. \"\"                   Gymnorhina ti~\r\n6           -43.6             147. \"\"                   Gymnorhina ti~\r\n# ... with 3 more variables: taxonConceptID <chr>, recordID <chr>,\r\n#   dataResourceName <chr>\r\n\r\nFor the purpose of this exercise, we’re going to filter records not on the mainland or Tasmania.\r\n\r\n\r\nfiltered_occ <- magpie_occ %>% filter(decimalLongitude < 155,\r\n                                      decimalLongitude > 110,\r\n                                      decimalLatitude > -45,\r\n                                      decimalLatitude < -10)\r\n\r\n\r\n\r\nPlotting binned data\r\nThe easiest way to create a hex map is using the hexbin package\r\n\r\n\r\nggplot(filtered_occ) +\r\n  geom_hex(mapping = aes(x = decimalLongitude, y = decimalLatitude), \r\n           bins = 47, \r\n           colour = \"white\") +\r\n  ylim(-45, -10) +\r\n  xlim(110, 155) +\r\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\")) +\r\n  coord_fixed() +\r\n  theme_bw() +\r\n  theme(\r\n    panel.border = element_blank(),\r\n    panel.grid.major = element_blank(),\r\n    panel.grid.minor = element_blank(),\r\n    axis.text = element_blank(),\r\n    axis.ticks = element_blank(),\r\n    axis.title = element_blank(),\r\n    legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nWhile automated methods are nice, it might sometimes be useful to create our hexagons manually. We can do this by manually creating hexagons, linking them to a grid of Australia, and adding our data of magpie counts to set the fill color of those hexagons. To achieve this, we first convert the map of Australia provided by ozmaps to the same coordinate system as ALA data:\r\n\r\n\r\naus <- st_transform(ozmaps::ozmap_country, 4326)\r\n\r\n\r\n\r\nWe then transform points from our data frame of magpie occurrences to the correct coordinates\r\n\r\n\r\npoints <- lapply(1:nrow(filtered_occ), function(x) {\r\n  st_point(c(as.numeric(filtered_occ[x,'decimalLongitude']),\r\n                        as.numeric(filtered_occ[x,'decimalLatitude'])))\r\n})\r\n\r\n\r\n\r\nNow build the hexagonal grid\r\n\r\n\r\ngrid_all <- st_make_grid(aus, cellsize = 1, what = \"polygons\", square = FALSE)[aus]\r\ngridSF <- st_as_sf(grid_all)\r\n\r\n# Find which polygon each point is in\r\nintersect <- st_intersects(st_as_sfc(points) %>% st_set_crs(4326), gridSF)\r\n\r\n# count the number of points in each hexagon\r\nfreqs <- as.data.frame(table(unlist(intersect)), stringsAsFactors = FALSE)\r\n\r\nnames(freqs) <- c(\"hex_id\", \"count\")\r\n\r\n\r\n\r\nAdd our magpie counts data to the hexagons and fill hexagons without data\r\n\r\n\r\nfreqs$hex_id <- as.integer(freqs$hex_id)\r\n\r\n# fill in the values for hexagons with no records\r\nfilled_freqs <- freqs %>%\r\n  complete(hex_id = full_seq(c(1,925), 1), fill = list(count = 0))\r\ngridSF$n <- filled_freqs$count\r\n\r\n\r\n\r\nFinally, build the plot\r\n\r\n\r\nggplot() +\r\n  geom_sf(data = gridSF, aes(fill = n), size = .01) +\r\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\"), na.value = \"white\", trans = \"log2\") +\r\n  ylim(-45, -10) +\r\n  xlim(110, 155) +\r\n  theme_bw() +\r\n  theme(\r\n    panel.border = element_blank(),\r\n    panel.grid.major = element_blank(),\r\n    panel.grid.minor = element_blank(),\r\n    axis.text = element_blank(),\r\n    axis.ticks = element_blank(),\r\n    axis.title = element_blank(),\r\n    legend.position = \"none\") \r\n\r\n\r\n\r\n\r\nThat’s it! All the extra work does make a difference in this case, providing a better representation of the spread of Mapgies across Australia. Manually constructing hex maps can be useful in other circumstances, too. For example, if we wanted to compare the number of magpies to contextual information within each polygon (such as rainfall or human population data), then manually constructing our own hexagons could help us to combine data from different sources.\r\nA final point is that we could have achieved the same result by creating polygons first, then querying the ALA for the number of magpie records in each polygon using galah_geolocate(). That’s a bit more challenging, and not worthwhile in this case; but it can be an efficient solution where you require information on more species than there are polygons, for example. We’ll come back to this point in a future blog post.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-04-14_hex-maps-for-species-occurrence-data/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/",
    "title": "Sunburst plots for taxonomic data",
    "description": "Since version 1.3.1 of `galah`, it has been possible to download taxonomic\ndata using a 'tree' format from the `data.tree` package. Here I'll demonstrate\nsome ideas for plotting these trees using circular diagrams.",
    "author": [
      {
        "name": "Martin Westgate",
        "url": {}
      }
    ],
    "date": "2022-02-17",
    "categories": [
      "Trees",
      "Eukaryota",
      "Animalia",
      "Chordata"
    ],
    "contents": "\r\n\r\nContents\r\nDownloading taxonomic trees\r\nGetting plot-ready data\r\nDrawing\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMartin Westgate\r\n\r\n\r\nDate:\r\n\r\n17 February, 2022\r\n\r\n\r\n\r\n\r\n\r\nTaxonomy is pretty important at the ALA. Every occurrence record in the atlas is linked to a unique taxonomic identifier. These identifiers are themselves drawn from expertly curated taxonomic datasets. This system of classification is so important to our infrastructure that we have a special name for it; the ‘taxonomic backbone’. But what does it look like?\r\nVisualising trees is not particularly easy for me; I didn’t train in it, and the data structures involved can be a bit complex. More importantly, until recently it was difficult to download detailed taxonomic information from the ALA. Since version 1.3.1 of galah, however, it has been possible to download taxonomic trees using the atlas_taxonomy() function. Let’s have a go at visualising these trees now.\r\nDownloading taxonomic trees\r\nThe first step is to choose a taxonomic group to represent in tree form. I’ve chosen the chordates (Phylum Chordata) because they aren’t too large a group and the names are fairly well-known. We can specify this within galah using the function galah_identify. The second piece of information we need to supply is how far ‘down’ the tree to travel. I’ve chosen the Order level here using galah_down_to(order); while we could have gone to the Family or even Genus, trying to traverse too many levels (i.e. to Genus or Species) would take a very long time. A full list of accepted ranks can be found by calling show_all_ranks().\r\n\r\n\r\nlibrary(galah)\r\nchordate_orders <- galah_call() |>\r\n  galah_identify(\"chordata\") |>\r\n  galah_down_to(order) |>\r\n  atlas_taxonomy()\r\n\r\n\r\n\r\nThe object returned by atlas_taxonomy is slightly unusual; it uses the data.tree package, meaning that the dataset is literally structured like a tree. This is notably different from other representations of networks, such as you might find in igraph, for example. To get an idea of what the data look like, we can use the inbuilt print method for this data type:\r\n\r\n\r\nlibrary(data.tree)\r\nprint(chordate_orders, pruneMethod = \"dist\", limit = 10)\r\n\r\n\r\n                            levelName\r\n1  Chordata                          \r\n2   ¦--Cephalochordata               \r\n3   ¦   °--Amphioxi                  \r\n4   ¦       °--... 1 nodes w/ 0 sub  \r\n5   ¦--Tunicata                      \r\n6   ¦   ¦--Appendicularia            \r\n7   ¦   ¦   °--... 1 nodes w/ 0 sub  \r\n8   ¦   ¦--Ascidiacea                \r\n9   ¦   ¦   °--... 5 nodes w/ 0 sub  \r\n10  ¦   °--Thaliacea                 \r\n11  ¦       °--... 3 nodes w/ 0 sub  \r\n12  °--Vertebrata                    \r\n13      ¦--Agnatha                   \r\n14      ¦   °--... 2 nodes w/ 2 sub  \r\n15      °--Gnathostomata             \r\n16          °--... 5 nodes w/ 134 sub\r\n\r\nThis shows there are three nodes directly beneath Chordata in the taxonomic hierarchy, of which the largest (by number of sub-nodes) is the vertebrates (Vertebrata). There is a lot we could do with this tree; each node contains a unique taxonomic identifer, for example, meaning that we could use individual nodes to make new queries using galah. However, for now a useful task is simply to visualise the structure of the whole tree.\r\nGetting plot-ready data\r\nTaxonomic trees are complex. While all species have a Kingdom, Phylum, Order, Class and Family, there are many intermediate categories that are ‘optional’. In practice, this means that when we convert to a data.frame for plotting, there are a lot of missing values; nodes that apply to some rows but not others.\r\n\r\n\r\ndf_rank <- ToDataFrameTypeCol(chordate_orders, type = \"rank\")\r\ndf_rank[10:20,]\r\n\r\n\r\n   rank_phylum rank_subphylum rank_class           rank_informal\r\n10    Chordata       Tunicata  Thaliacea                    <NA>\r\n11    Chordata     Vertebrata       <NA>         Myxini, Agnatha\r\n12    Chordata     Vertebrata       <NA> Petromyzontida, Agnatha\r\n13    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n14    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n15    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n16    Chordata     Vertebrata       Aves           Gnathostomata\r\n17    Chordata     Vertebrata       Aves           Gnathostomata\r\n18    Chordata     Vertebrata       Aves           Gnathostomata\r\n19    Chordata     Vertebrata       Aves           Gnathostomata\r\n20    Chordata     Vertebrata       Aves           Gnathostomata\r\n   rank_subclass rank_superorder rank_subinfraclass rank_infraclass\r\n10          <NA>            <NA>               <NA>            <NA>\r\n11          <NA>            <NA>               <NA>            <NA>\r\n12          <NA>            <NA>               <NA>            <NA>\r\n13  Lissamphibia            <NA>               <NA>            <NA>\r\n14          <NA> Labyrinthodonta               <NA>            <NA>\r\n15          <NA>       Salientia               <NA>            <NA>\r\n16    Neognathae            <NA>               <NA>            <NA>\r\n17    Neognathae            <NA>               <NA>            <NA>\r\n18 Palaeognathae            <NA>            Ratitae            <NA>\r\n19 Palaeognathae            <NA>            Ratitae            <NA>\r\n20          <NA>            <NA>               <NA>            <NA>\r\n   rank_subdivision zoology         rank_order\r\n10                     <NA>            Salpida\r\n11                     <NA>       Myxiniformes\r\n12                     <NA> Petromyzontiformes\r\n13                     <NA>              Anura\r\n14                     <NA>      Temnospondyli\r\n15                     <NA>       Sphenodontia\r\n16                     <NA>   Accipititrifomes\r\n17                     <NA>    Phaethontifomes\r\n18                     <NA>      Casuariifomes\r\n19                     <NA>   Dinornithiformes\r\n20                     <NA>       Anseriformes\r\n\r\nThese missing values will show up as empty sections in the resulting diagram, which isn’t ideal. Instead, we can build this data.frame so as to place all nodes in order by row, with empty ‘levels’ being placed at the end. This also avoids the problem where ‘unnamed’ ranks are grouped in the same column. To achieve this, we simply choose a different node attribute (level in this case) to supply to the type argument.\r\n\r\n\r\ndf_level <- ToDataFrameTypeCol(chordate_orders, type = \"level\")\r\ndf_level[10:20, ]\r\n\r\n\r\n    level_1    level_2       level_3        level_4\r\n10 Chordata   Tunicata     Thaliacea        Salpida\r\n11 Chordata Vertebrata       Agnatha         Myxini\r\n12 Chordata Vertebrata       Agnatha Petromyzontida\r\n13 Chordata Vertebrata Gnathostomata       Amphibia\r\n14 Chordata Vertebrata Gnathostomata       Amphibia\r\n15 Chordata Vertebrata Gnathostomata       Amphibia\r\n16 Chordata Vertebrata Gnathostomata           Aves\r\n17 Chordata Vertebrata Gnathostomata           Aves\r\n18 Chordata Vertebrata Gnathostomata           Aves\r\n19 Chordata Vertebrata Gnathostomata           Aves\r\n20 Chordata Vertebrata Gnathostomata           Aves\r\n              level_5          level_6          level_7 level_8\r\n10               <NA>             <NA>             <NA>    <NA>\r\n11       Myxiniformes             <NA>             <NA>    <NA>\r\n12 Petromyzontiformes             <NA>             <NA>    <NA>\r\n13       Lissamphibia            Anura             <NA>    <NA>\r\n14    Labyrinthodonta    Temnospondyli             <NA>    <NA>\r\n15          Salientia     Sphenodontia             <NA>    <NA>\r\n16         Neognathae Accipititrifomes             <NA>    <NA>\r\n17         Neognathae  Phaethontifomes             <NA>    <NA>\r\n18      Palaeognathae          Ratitae    Casuariifomes    <NA>\r\n19      Palaeognathae          Ratitae Dinornithiformes    <NA>\r\n20       Anseriformes             <NA>             <NA>    <NA>\r\n\r\nAnother problem in this dataset is the existence of duplicated taxonomic names. This happens because different authorities place the same taxon in different parts of the tree, and while the ALA tries to clean up these issues, some disagreements remain. The code below assumes that each name is only present once, so we have to remove duplicates to proceed. Fortunately there is a function in package base that flags duplcated values as TRUE and unique values as FALSE. We can use this function to identify rows where order is not unique.\r\n\r\n\r\nlibrary(dplyr)\r\nkeep_rows <- !duplicated(df_rank$rank_order)\r\ndf_rank <- filter(df_rank, keep_rows)\r\ndf_level <- filter(df_level, keep_rows)\r\n\r\n\r\n\r\nThe next step is to determine how to represent this structure in a plot. At the moment we can’t do this, because the data are in ‘wide’ format. Instead, we need to reorder our data so that each node/taxon is represented once, and other plotting aesthetics can be added as additional columns. To achieve this, we first convert to ‘long’ format, preserving information like what row and column each taxonomic label was recorded in.\r\n\r\n\r\ndf_long <- tibble(\r\n  row = rep(seq_len(nrow(df_level)), ncol(df_level)),\r\n  level = rep(seq_len(ncol(df_level)), each = nrow(df_level)),\r\n  taxon = do.call(c, df_level)) |> \r\n  filter(!is.na(taxon)) # remove missing values\r\n\r\n\r\n\r\nThen, we can summarize this plot so that each row is a single taxon, recording some metadata about rows and columns from the original dataset\r\n\r\n\r\ndf_plot <- df_long |>\r\n  group_by(taxon) |>\r\n  summarize(\r\n    xmin = min(row) - 1, \r\n    xmax = max(row), \r\n    ymin = level[1] - 1,\r\n    ymax = level[1])\r\n     \r\ndf_plot\r\n\r\n\r\n# A tibble: 161 x 5\r\n   taxon             xmin  xmax  ymin  ymax\r\n   <chr>            <dbl> <int> <dbl> <int>\r\n 1 Acanthopterygii     66    79     6     7\r\n 2 Accipititrifomes    15    16     5     6\r\n 3 Accipitriformes     21    22     4     5\r\n 4 Actinopterygii      56    96     4     5\r\n 5 Agnatha             10    12     2     3\r\n 6 Albuliformes        62    63     6     7\r\n 7 Amphibia            12    15     3     4\r\n 8 Amphioxi             0     1     2     3\r\n 9 Amphioxiformes       0     1     3     4\r\n10 Anguilliformes      63    64     6     7\r\n# ... with 151 more rows\r\n\r\nDrawing\r\nOur dataset now contains all the information we need to plot the structure of our taxonomic tree. As usual, we’re going to plot this with ggplot2.\r\n\r\n\r\nlibrary(ggplot2)\r\nggplot(df_plot) +\r\n  geom_rect(\r\n    mapping = aes(\r\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \r\n      group = taxon,\r\n      fill = ymax),\r\n    color = \"white\")\r\n\r\n\r\n\r\n\r\nWhile this is (probably) accurate, it’s not very informative. The most obvious missing element is labels; to add these, we’ll need to determine which nodes are ‘leaves’, and which are ‘branches’. We’ll also want to restrict labelling to larger branches, to avoid the text looking crowded. Finally, there is no need to label leaves with both a rectangle and text; so we’ll remove the leaf rectangles from the plot.\r\n\r\n\r\ndf_plot <- df_plot |> mutate(\r\n  x_dist = xmax - xmin,\r\n  is_leaf = taxon %in% df_rank$rank_order)\r\n\r\np <- ggplot() +\r\n  geom_rect(\r\n    data = filter(df_plot, !is_leaf),\r\n    mapping = aes(\r\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \r\n      group = taxon,\r\n      fill = ymax),\r\n    color = \"white\")\r\n\r\np +\r\n  # branch labels\r\n  geom_text(\r\n    data = filter(df_plot, x_dist > 5),\r\n    mapping = aes(\r\n      x = xmin + (x_dist * 0.5), \r\n      y = ymin + 0.5,\r\n      label = taxon),\r\n    color  = \"white\",\r\n    size = 3) +\r\n  # leaf labels\r\n  geom_text(\r\n    data = filter(df_plot, is_leaf),\r\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\r\n    angle = 90,\r\n    hjust = 0,\r\n    size = 2.5,\r\n    color = \"grey20\") \r\n\r\n\r\n\r\n\r\nThis is better, but not ideal. A much more pleasing look is to use coord_polar() to generate a circular plot; but this leads to linear text on a circular plot, which looks messy. Fortunately, the new package geomtextpath solves this problem. All we have to do is replace geom_text with geom_textpath, leaving all other code the same, and add coord_polar() at the end.\r\n\r\n\r\nlibrary(geomtextpath)\r\n\r\np <- p + \r\n  geom_textpath(\r\n    data = filter(df_plot, x_dist > 5),\r\n    mapping = aes(\r\n      x = xmin + (x_dist * 0.5), \r\n      y = ymin + 0.5,\r\n      label = taxon),\r\n    color  = \"white\",\r\n    size = 2.7) +\r\n  geom_textpath(\r\n    data = filter(df_plot, is_leaf),\r\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\r\n    angle = 90,\r\n    hjust = 0,\r\n    size = 2.3,\r\n    color = \"grey20\") +\r\n  coord_polar()\r\np\r\n\r\n\r\n\r\n\r\nFinally, we can add some finishing touches by changing the color scheme, hiding the background colors and legend, and resizing the y axis so all the labels are visible.\r\n\r\n\r\nlibrary(viridis)\r\n\r\np +\r\n  scale_fill_viridis(begin = 0, end = 0.9, direction = -1) +\r\n  lims(y = c(0, 9)) +\r\n  theme_void() + \r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nDone! This is a fun plot, but there are ways it could be expanded or improved, the most obvious of which is to find ways to add supplementary information. Wouldn’t it be great, for example, to add leaf-level record counts as marginal barplots? Or scale the size of segments to the number of records, rather than the number of clades? While none of these are impossible, I’m going to leave this here for now. I hope you like the result!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-20_creating-a-color-palette-from-an-image/",
    "title": "Creating a color palette from an image",
    "description": "There are hundreds of color palettes in the R ecosystem, but sometimes we\nmight want to use colors from a specific image. Here I show how to \nuse the `paletter` package to create a color palette for the 2020 Eucalypt of \nthe Year: the Western Australian Gimlet.",
    "author": [
      {
        "name": "Martin Westgate",
        "url": {}
      }
    ],
    "date": "2021-03-20",
    "categories": [
      "Summaries",
      "Eukaryota",
      "Plantae"
    ],
    "contents": "\r\n\r\nContents\r\nColors in R\r\nExtracting colors\r\nCreating a plot\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMartin Westgate\r\n\r\nDate:\r\n\r\nMarch 2021\r\n\r\n\r\n\r\nColors in R\r\nColor palettes are important to people, and the R ecosystem includes literally hundreds of possible palettes. If you want a “complete” list, go and check out Emil Hvitfeldt’s list of palettes here; but in practice there are only a few that we use routinely. Our default at ALA labs is to use viridis for continuous scales, because (to quote their CRAN page) it’s color-blind friendly, perceptually uniform, and pretty. The default purple-green-yellow color scheme is lovely, but I’m a big fan of ‘magma’, which has a black-purple-orange-yellow scheme\r\n\r\n\r\nlibrary(galah)\r\nlibrary(ggplot2)\r\nlibrary(viridis)\r\n\r\nrecords <- ala_counts(group_by = \"cl22\")\r\nrecords$State <- factor(seq_len(nrow(records)), labels = records$cl22) \r\n\r\nggplot(records, aes(x = State, y = log10(count), fill = count)) + \r\n  geom_bar(stat = \"identity\") +\r\n  coord_flip() +\r\n  scale_fill_viridis(option = \"magma\", begin = 0.10, end = 0.95) +\r\n  theme_bw() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nMy default for categorical color schemes is the ‘dark2’ palette from RColorBrewer; but given the subject matter of our work, it’s worth mentioning the wonderful feather package by Shandiya Balasubramaniam, which gives colors based on Australian bird plumage\r\n\r\n\r\n# remotes::install_github(repo = \"shandiya/feathers\")\r\nlibrary(feathers)\r\n\r\nrcfd <- ala_counts(\r\n  taxa = select_taxa(\"Rose-crowned Fruit-Dove\"),\r\n  group_by = \"cl22\")\r\nrcfd$State <- factor(seq_len(nrow(rcfd)), labels = rcfd$cl22) \r\n\r\nggplot(rcfd, aes(x = State, y = log10(count), fill = State)) + \r\n  geom_bar(stat = \"identity\") +\r\n  coord_flip() +\r\n  scale_fill_manual(values = get_pal(\"rose_crowned_fruit_dove\")) +\r\n  theme_bw() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nAll of this is fine, but what if you have a specific image that you want to take colors from? A logical choice is to pick the colors you want using an image editting program, but if we want to try something automated, there are options in R as well.\r\nExtracting colors\r\nNational Eucalypt Day aims to raise awareness about Eucalypts and celebrate their influence on the lives of Australians. In honour of National Eucalypt day, we wanted to created a plot based on occurrences data held in the Atlas of Living Australia, themed using colours from actual Eucalypts.\r\nWe used this image from a tweet by Dean Nicolle:\r\n\r\nHappy 'National Eucalypt Day'!The Western Australian gimlet (Eucalyptus salubris) has just been announced as Eucalypt of the Year for 2021. Renowned for its fluted, smooth, shiny, and colourful trunk & branches. pic.twitter.com/pOsufQtxWS— Dean Nicolle (@DeanNicolle1) March 22, 2021\r\n\r\n\r\nImage of Eucalyptus salubris by Dean NicolleFirst, get observations of the Eucalypt of the Year 2021 from ALA using the galah package. Specifically, we use ala_counts() to determine how many records of Eucalyptus salubris are held by the ALA:\r\n\r\n\r\nn_records <- ala_counts(taxa = select_taxa(\"Eucalyptus salubris\"))\r\n\r\n\r\n\r\nThen get a color scheme from images of the species in question using the paletter package (which needs to be installed from GitHub) \r\n\r\n\r\n# remotes::install_github(\"AndreaCirilloAC/paletter\")\r\nlibrary(paletter)\r\n\r\nimage_pal <- create_palette(\r\n  image_path = \"./data/Dean_Nicolle_Esalubris_image_small.jpeg\",\r\n  type_of_variable = \"categorical\",\r\n  number_of_colors = 15)\r\n\r\n\r\n\r\n\r\n\r\n\r\nNote that we downsized the image before running the paletter code, as large images take much longer to process.\r\nCreating a plot\r\nOnce we have this palette, the obvious question is what kind of plot to draw. We could have done a map, but those can be a bit boring. We decided to try something that represented the number of observations we had of this species at ALA, and included color, but was otherwise just a pretty picture that didn’t need to contain any further information. Rather than have a traditional x and y axis, therefore, we decided to try out the igraph package to plot the points in an interesting way.\r\nFirst, we create a vector containing as many points as we want to display, and distribute our colors among them as evenly as possible\r\n\r\n\r\n# create a vector to index colours\r\ncolour_index <- rep(seq_along(image_pal),\r\n  each = floor(n_records / length(image_pal)))\r\n# correct rounding errors\r\ncolour_index <- c(colour_index,\r\n  rep(length(image_pal), n_records - length(colour_index)))\r\n\r\n\r\n\r\nThen we can create a network using igraph, and use it to create a layout for our points\r\n\r\n\r\nlibrary(igraph)\r\n\r\ngraph_list <- lapply(c(1:15), function(a){\r\n  lookup <- which(colour_index == a)\r\n  return(data.frame(\r\n    from = lookup[c(1:(length(lookup)-1))],\r\n    to = lookup[c(2:length(lookup))]))\r\n  })\r\ngraph_df <- as.matrix(do.call(rbind, graph_list))         # build matrix\r\ncolour_graph <- graph_from_edgelist(graph_df)             # create network graph\r\n\r\n# convert to a set of point locations\r\ntest_layout <- as.data.frame(layout_nicely(colour_graph)) # convert to df\r\ncolnames(test_layout) <- c(\"x\", \"y\")                      # change colnames\r\ntest_layout$colour_index <- factor(colour_index)          # add colour_index col\r\n\r\n\r\n\r\nFinally, we draw the plot with ggplot2, removing axes with theme_void()\r\n\r\n\r\nggplot(test_layout, aes(x = x, y = y, colour = colour_index)) +\r\n  geom_point(size = 3, alpha = 0.9) +\r\n  scale_color_manual(values = image_pal) +\r\n  coord_fixed() +\r\n  theme_void() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nThat’s it! While I like the effect here, I think the paletter package is best suited to cases where there are large areas of strongly contrasting colors; it’s less ideal for images with subtle color differences. It also doesn’t appear to have been updated lately, which may mean it’s not being supported any more. But I’m happy with this plot, and would definitely consider using it again.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-20_creating-a-color-palette-from-an-image/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  }
]
