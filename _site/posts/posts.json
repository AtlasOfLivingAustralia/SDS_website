[
  {
<<<<<<< HEAD
    "path": "posts/2022-05-17_3d-map/",
    "title": "Download plant species data by hexagon to make a 3D hex map\n",
    "description": "Making plots eye-catching can be useful for science communication. Here, we \nshow how to make 3D plots in R with the `rayshader` package by visualising the \nnumber of species identified from ALA observations since 2020",
    "author": [
      {
        "name": "Dax Kellie",
=======
    "path": "posts/2022-05-23-multiple-scales-in-choropleth-maps-with-ggnewscale/",
    "title": "Multiple scales in choropleth maps with {ggnewscale}",
    "description": "Wherein we download records of plants from the ALA and scale the dizzy heights of adding multiple colour scales to differentiate marine and terrestrial records",
    "author": [
      {
        "name": "Shandiya Balasubramaniam",
>>>>>>> sb-ggnewscale
        "url": {}
      }
    ],
    "date": "2022-05-23",
    "categories": [
<<<<<<< HEAD
      "Eukaryota",
      "Plantae",
      "Maps"
    ],
<<<<<<< HEAD
    "contents": "\r\n\r\nContents\r\nMake a hexagon map\r\nDownload species data\r\nPlot number of species\r\nRender in 3D\r\n\r\n\r\n\r\n\r\n\r\n\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nDax\r\nKellie\r\n\r\n\r\nDate:\r\n\r\n23 May, 2022\r\n\r\n\r\n\r\n\r\n\r\nGrabbing people’s attention in a content-filled world can be\r\ndifficult. 3D maps can be particularly eye-catching, and thanks to the\r\nrayshader package\r\nit has become relatively simple to make a beautiful 3D plot from a plot\r\nmade with ggplot2.\r\nIn this post, we’ll make a 3D hex map of the number of plant species\r\nidentified from ALA observations since 2020. This map builds on a previous\r\nhex map post, but this time we will use a more unique “grid-to-data”\r\nmethod to download our data, where instead of plotting hexagons over our\r\nmap after extracting data, we’ll create a grid of hexagons that\r\nmap to Australia before extracting any data and query the ALA\r\nfor data for each hexagon. This method is cool because it saves\r\na lot of work wrangling your data to fit your plot later on.\r\nMake a hexagon map\r\nFirst let’s download the necessary packages\r\n\r\n\r\n# packages\r\nlibrary(galah)      # To download species data\r\nlibrary(rayshader)  # For 3d rendering\r\nlibrary(tidyverse)  # Data wrangling\r\nlibrary(here)       # Safe paths\r\nlibrary(sf)         # Spatial features\r\nlibrary(ozmaps)     # For map of oz\r\n\r\n\r\n\r\nNow let’s get a map of Australia from the ozmaps\r\npackage\r\n\r\n\r\n# get a map and project to WGS84\r\noz_wgs84 <- ozmap_data(data = \"country\") |>\r\n  st_transform(crs = st_crs(\"WGS84\"))\r\n\r\n## check map\r\nggplot(oz_wgs84) + geom_sf()\r\n\r\n\r\n\r\n\r\nNext let’s create our grid of hexagons and do some tidying to make\r\nsure the hexagons are only over the land\r\n\r\n\r\n# create grid\r\noz_grid <- st_make_grid(oz_wgs84,\r\n                        what = \"polygons\",\r\n                        cellsize = 1.0,\r\n                        square = FALSE,\r\n                        flat_topped = TRUE)\r\n\r\n# subset to grid cells that are within land\r\nkeep_hexes <- st_intersects(oz_grid, oz_wgs84)\r\nkeep_hexes <- as.data.frame(keep_hexes)$row.id\r\noz_grid <- oz_grid[keep_hexes]\r\n\r\n\r\n\r\nIf we plot our new oz_grid over our map, we can see how\r\nthe hexagons fill our map of Australia\r\n\r\n\r\n## check\r\nggplot() +\r\n  geom_sf(data = oz_wgs84) +\r\n  geom_sf(data = oz_grid, fill = NA, color = \"red\")\r\n\r\n\r\n\r\n\r\nDownload species data\r\nNow that we have our grid of hexagons, we can download data from the\r\nALA using the galah\r\npackage. Rather than downloading all data on the number of species\r\nidentified since 2020 and then plotting the data as hexagons, we will\r\nmake a function that sends individual queries to return the number of\r\nspecies identified within each hexagon.\r\nOur funtion get_counts() works in 3 parts:\r\nThe first part does some necessary editing of each Well Known\r\nText (WKT) string so that they are compatible with\r\ngalah.\r\nThe second part builds a query to download ALA data, beginning\r\nwith galah_call(). We add the WKT for each hexagon to our\r\nquery with galah_geolocate(), specify that we want to\r\nreturn only Plantae and Chlorophyta species with\r\ngalah_identify(), and filter to only records from 2020\r\nonwards with galah_filter(). We’ll also add\r\ngalah_filter(profile = \"ALA\") to use a standard ALA data\r\nquality filter (known in the ALA as as a data “profile”). We end our\r\nquery with atlas_counts(type = \"species\") to return counts\r\nof species, rather than counts of records (which is the default\r\nsetting).\r\nThe final part makes sure that if any hexagons have 0 species\r\nidentified, they will return a 0 rather than an NA, which\r\ntriggers an error in R.\r\n\r\n\r\nget_counts <- function(hexagon){\r\n  \r\n    # convert to wkt\r\n    wkt_string <- st_as_text(oz_grid[[hexagon]]) %>%\r\n      sub(\")))\", \"))\", .) %>%\r\n      sub(\"POLYGON \", \"POLYGON\", .)\r\n    \r\n    # get counts\r\n    result <- galah_call() |>\r\n      galah_geolocate(wkt_string) |>\r\n      galah_identify(\"plantae\", \"chlorophyta\") |>\r\n      galah_filter(profile = \"ALA\",\r\n                   decimalLongitude > 110,\r\n                   year >= 2020) |>\r\n      atlas_counts(type = \"species\", # get species counts\r\n                   limit = NULL)\r\n    \r\n    # light formatting to catch errors\r\n    if(is.null(result)){\r\n      tibble(count = NA, id = hexagon)\r\n    }else{\r\n      result$id <- hexagon\r\n      result\r\n    }\r\n  }\r\n\r\n\r\n\r\nWe can use purrr::map() to run this function recursively\r\nfor each hexagon. Then we can bind the separate lists into one\r\ndata.frame with purrr::map_dfr(). As oz_grid\r\nis a spatial object containing POLYGONs (which R treats\r\nslightly differently to a data.frame), we have to use\r\nseq_along(oz_grid) to enable us to run the function for\r\neach line, which corresponds to each POLYGON.\r\nIMPORTANT NOTE: This function will send\r\nlots of queries all at once to the ALA, so it is best\r\nto use restraint on how many times you run it because it can take a long\r\ntime and, if run many times in a row, can make it take even longer.\r\n\r\n\r\n# download number of species for each polygon\r\ncounts_list <- map(seq_along(oz_grid), get_counts)\r\n\r\n# bind lists to data frame\r\ncounts_df <- map_dfr(counts_list, rbind)\r\n\r\n\r\n\r\ncounts_df now contains a single count of species for\r\neach hexagon, indicated by a unique id\r\n\r\n\r\nhead(counts_df, 10L)\r\n\r\n\r\n# A tibble: 10 x 2\r\n   count    id\r\n   <dbl> <int>\r\n 1   396     1\r\n 2   302     2\r\n 3   457     3\r\n 4   178     4\r\n 5  1022     5\r\n 6   443     6\r\n 7   507     7\r\n 8   438     8\r\n 9   592     9\r\n10     5    10\r\n\r\nNow let’s merge our species counts in counts_df to our\r\noz_grid hexagons so we can plot them. To do so, we’ll\r\nconvert oz_grid to a tibble called oz_df, add\r\na blank count column, and fill that column with the species\r\ncounts in counts_df for each hexagon by\r\nid.\r\n\r\n\r\n# convert to tibble, attach counts\r\noz_df <- st_as_sf(oz_grid)\r\noz_df$count <- NA\r\noz_df$count[counts_df$id] <- counts_df$count\r\n\r\n\r\n\r\nLet’s see the final result by checking the hexagons with highest\r\nspecies counts\r\n\r\n\r\n# See top hexagons\r\noz_df %>%\r\n  arrange(desc(count)) %>%\r\n  head(10L)\r\n\r\n\r\nSimple feature collection with 10 features and 1 field\r\nGeometry type: POLYGON\r\nDimension:     XY\r\nBounding box:  xmin: 137.8823 ymin: -38.63203 xmax: 153.7594 ymax: -26.63203\r\nGeodetic CRS:  WGS 84\r\n   count                              x\r\n1   2542 POLYGON ((150.0066 -33.6320...\r\n2   2144 POLYGON ((150.8726 -34.1320...\r\n3   2063 POLYGON ((144.8105 -37.6320...\r\n4   2006 POLYGON ((150.0066 -34.6320...\r\n5   1951 POLYGON ((152.6047 -27.1320...\r\n6   1943 POLYGON ((152.6047 -28.1320...\r\n7   1802 POLYGON ((150.8726 -33.1320...\r\n8   1610 POLYGON ((151.7387 -27.6320...\r\n9   1601 POLYGON ((137.8823 -34.6320...\r\n10  1573 POLYGON ((143.9444 -38.1320...\r\n\r\nPlot number of species\r\nThe first step to making our 3D map is to make a 2D map with\r\nggplot2. I have set the fill of our map to use\r\noz_df’s count column and log transformed it to\r\nmake our final scale easier to read. The\r\nscale_fill_distiller() function has a nice “Greens” palette\r\nto make our plant species data look extra planty, and I have added\r\ncustom limits and labels to make sure the scale is understandable.\r\n\r\n\r\nhex_map <- ggplot() +\r\n  geom_sf(\r\n    data = oz_df,\r\n    mapping = aes(fill = log10(count + 1)), # log10 + 1 transformed\r\n    alpha = 1,\r\n    color = NA) +\r\n  scale_fill_distiller(name = \"Number of species \\n(since 1 Jan, 2020)\",\r\n                       type = \"seq\",\r\n                       direction = 1,\r\n                       limits = c(0,4),\r\n                       labels = c(\"10\", \"100\", \"1,000\"),\r\n                       palette = \"Greens\",\r\n                       # edit legend to be horizontal-bottom\r\n                       guide = guide_colorsteps(direction = \"horizontal\",\r\n                                                label.position = \"top\",\r\n                                                title.position = \"bottom\",\r\n                                                title.hjust = 0.5)\r\n                       ) +\r\n  # add map\r\n  geom_sf(data = oz_wgs84,\r\n          color = NA,\r\n          fill = NA)  +\r\n  # crop map\r\n  coord_sf(xlim = c(110, 155), \r\n           ylim = c(-45, -10)) +\r\n  # Adjust text and make aesthetic more minimal\r\n  theme(title = element_text(face = \"bold\"),\r\n        legend.title = element_text(size = 19),\r\n        legend.position = \"bottom\",\r\n        legend.key.width = unit(28, 'mm'),\r\n        legend.text = element_text(size = 16),\r\n        plot.background = element_rect(fill = 'white', colour = 'white'),\r\n        panel.background = element_rect(fill = 'white', colour = 'white'),\r\n        axis.title = element_blank()\r\n        )\r\n\r\nhex_map\r\n\r\n\r\n\r\n\r\nRender in 3D\r\nIt’s time to get 3-Dimensional! Using\r\nrayshader::plot_gg(), we can render a nice 3d version of\r\nour plot1\r\n\r\n\r\n# Render 3d plot\r\nplot_gg(hex_map, \r\n        width = 9, \r\n        height = 8,\r\n        scale = 300, # adjust height of 3D transformation\r\n        windowsize = c(1200, 960), # adjust window of rendered plot\r\n        fov = 75,    # adjust size/strength of blur around outer edges\r\n        zoom = 0.37, \r\n        theta = 320, # adjust left-right rotation of view\r\n        phi = 33)    # adjust height of view\r\n\r\n\r\n\r\n\r\n\r\n\r\nLooks great! Finally, we can save our plot using\r\nrender_snapshot()\r\n\r\n\r\n# save\r\nSys.sleep(0.2)\r\nrender_snapshot(here(\"folder\", \"subfolder\", \"3d-map.png\"))\r\n\r\n\r\n\r\nIn this case, a 3D map makes the areas with many and few species very\r\nnoticeable, which is a useful message to communicate.\r\nHowever, in general, one should be careful about using 3D plots\r\nwithout first considering the main messages they want people to take\r\naway from their data, and whether a 3D figure communicates this better\r\nthan a 2D alternative. People aren’t as good at quickly interpreting\r\ndifferences in height, shape or location in 3D plots compared to 2D\r\nplots. One reason for this weakness is that most 3D plots can only be\r\nviewed from a single angle. Depending on what angle the view point of\r\nthe plot is set to, the literal differences in heights or locations\r\nbetween shapes might change, even if their actual differences in the\r\ndata they represent don’t change. Looking at a 3D map from above, in the\r\nmiddle, or below changes how the shapes appear, and sometimes they may\r\nnot accurately represent the true differences between things\r\nyou want to compare in your plot. This quirk of 3D plots makes it easier\r\nfor people to misinterpret your plot and, as a result, take away the\r\nwrong message from the data (this idea is known as the principle\r\nof proportional ink (Tufte, 1983).\r\nCarl Bergstrom has written an\r\nexcellent explanation of why this principle matters in data\r\nvisualisation)\r\nEven so, 3D plots can be a beautiful way to see the number of plant\r\nspecies identified in the ALA since 2020. Even cooler, querying species\r\ndata from the ALA for each hexagon in our map with galah\r\ncan be an efficient way to download data and reduce data wrangling work\r\nlater on!\r\n\r\nIf you get a weird error related to\r\nthe scales package, updating to the latest version should\r\nfix it: https://github.com/tylermorganwall/rayshader/issues/181#:~:text=Update%20to%20the,install.packages(%27rayshader%27)\r\n↩︎\r\n",
    "preview": {},
    "last_modified": "2022-05-23T17:07:08+10:00",
    "input_file": "3d-map.knit.md"
=======
      "Plantae",
      "Chlorophyta",
      "Maps"
    ],
    "contents": "\n\nContents\nPart 1: Where we\nintrepidly get data\nPart\n2: Where we fearlessly tidy, transform, and join\nPart 3: Where we map\nwith gay abandon\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAuthor:\n\nShandiya\nBalasubramaniam\n\n\nDate:\n\n23 May, 2022\n\n\n\n\n\n\n“I found I could say things with color and shapes that I couldn’t say\nany other way”\n- Georgia O’Keeffe\n\nChoropleth maps visually represent how aggregated summaries of a\nvariable (e.g. density of lamp posts, per capita books read) vary across\ngeographic areas. These maps require two inputs: a geospatial object\nwith information on regional boundaries, and a numerical variable that\ncan be mapped to each geographic unit using colour. Here, I walk through\nthe process of mapping the density of plant records from the ALA to\ngeographic bioregions across Australia, using two colour scales to\ndifferentiate between marine and terrestrial records.\nPart 1: Where we intrepidly\nget data\nLet’s start by loading the packages we’ll need.\n\n\nlibrary(galah)\nlibrary(here)\nlibrary(sf)\nlibrary(rmapshaper)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(showtext)\nlibrary(ggnewscale)\n\n\n\nNext up, we’ll need some regional boundaries. I think the IBRA7\nand IMCRA4\nbioregions will work nicely for what we’re planning. These boundaries\nclassify Australia’s landscapes and waters into geographically distinct\nbioregions based on variables like climate, geomorphology, and species\ninformation. After downloading the data, we can read it in using the\nsf package and check that it looks correct. Here, I’ve also\nelected to use ms_simplify() from the\nrmapshaper package to simplify the geospatial features and\nspeed up computation.\n\n\n# read in IMCRA shapefile\nimcra_shp <- st_read(here(\"_posts\", \n                          \"data\",\n                          \"imcra_mesoscale_bioregions\",\n                          \"imcra4_meso.shp\"), \n                     quiet = TRUE) |> \n  ms_simplify(keep = 0.1)\n\nplot(imcra_shp$geometry)\n\n# read in IBRA shapefile\nibra_shp <- st_read(here(\"_posts\",\n                         \"data\",\n                         \"IBRA7_regions\",\n                         \"ibra7_regions.shp\"),\n                    quiet = TRUE) |> \n  ms_simplify(keep = 0.1)\n\nplot(ibra_shp$geometry)\n\n\n\n\nAnd finally, let’s get the number of plant records in the ALA using\nthe galah package, grouped by IBRA or IMCRA region. To do\nthis, we need to know what the ALA calls the IBRA and IMCRA layers.\nWe’ll get this information using the search_fields()\nfunction.\n\n\ngalah::search_fields(\"IBRA\")\n\n\n# A tibble: 5 × 4\n  id     description                                       type  link \n  <chr>  <chr>                                             <chr> <chr>\n1 cl914  \"IBRA 6 Sub Regions IBRA 6 sub regions\"           laye… \"htt…\n2 cl3    \"Western Australian Biodiversity Science Researc… laye… \"htt…\n3 cl20   \"IBRA 6 Regions Interim Biogeographic Regionalis… laye… \"htt…\n4 cl1049 \"IBRA 7 Subregions IBRA 7 Subregions\"             laye… \"htt…\n5 cl1048 \"IBRA 7 Regions Interim Biogeographic Regionalis… laye… \"htt…\n\ngalah::search_fields(\"IMCRA\")\n\n\n# A tibble: 2 × 4\n  id    description                                        type  link \n  <chr> <chr>                                              <chr> <chr>\n1 cl966 IMCRA Meso-scale Bioregions IMCRA Meso-scale Bior… laye… http…\n2 cl21  IMCRA 4 Regions Integrated Marine and Coastal Reg… laye… http…\n\nGreat! Now that we know the IBRA layer we’re after is called\ncl1048 and the IMCRA layer, cl966, we\ncan pass a query with galah_call(), which lets us structure\nthe query using pipes. We can specify that we only want plant records\nmatching Plantae or Chlorophyta using\ngalah_identify(), apply the default set of ALA data quality\nfilters to remove poor quality records using\ngalah_filter(), group records by region using\ngalah_group_by(), and finally return the counts of records\nthat match all our criteria with atlas_counts().\n\n\n# counts in IBRA regions\nibra_counts <- galah_call() |>\n  galah_identify(\"plantae\", \"chlorophyta\") |>\n  galah_filter(profile = \"ALA\") |> \n  galah_group_by(\"cl1048\") |>      # IBRA regions\n  atlas_counts()\n\nhead(ibra_counts)\n\n\n# A tibble: 6 × 2\n  cl1048                      count\n  <chr>                       <int>\n1 Sydney Basin              2248661\n2 South Eastern Highlands   1408075\n3 South East Corner          993454\n4 NSW North Coast            764375\n5 South Eastern Queensland   704702\n6 Murray Darling Depression  696388\n\n# counts in IMCRA regions\nimcra_counts <- galah_call() |>\n  galah_identify(\"plantae\", \"chlorophyta\") |>\n  galah_filter(profile = \"ALA\") |> \n  galah_group_by(\"cl966\") |>      # IMCRA bioregions\n  atlas_counts()\n\nhead(imcra_counts)\n\n\n# A tibble: 6 × 2\n  cl966                count\n  <chr>                <int>\n1 Victorian Embayments 23165\n2 Shoalwater Coast     19276\n3 Lucinda-Mackay Coast 18421\n4 Bruny                18357\n5 Flinders             17525\n6 Central Victoria     17426\n\nPart 2:\nWhere we fearlessly tidy, transform, and join\nWe’ve now got the two inputs we need to make a choropleth: IBRA/IMCRA\nboundaries, and counts of plant records in each region. To create a\nplot, we need to combine the geospatial and numeric data. But first, a\nlittle light tidying.\nSince we’re going to be joining the spatial and count data, we need\nto be sure that the names of the IBRA/IMCRA regions match in both\ndatasets. We check this thusly.\n\n\n# check region names match\nsetdiff(ibra_counts$cl1048, ibra_shp$REG_NAME_7)\n\n\ncharacter(0)\n\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\n\n\n[1] \"Pilbarra (nearshore)\" \"Pilbarra (offshore)\" \n\nHmm… Looks like the IBRA region names match in both datasets, but not\nthe IMCRA. Let’s dig a bit further.\n\n\n# check the reverse for IMCRA names\nsetdiff(imcra_shp$MESO_NAME, imcra_counts$cl966)\n\n\n[1] \"Pilbara (offshore)\"  \"Pilbara (nearshore)\"\n\nOk, so Pilbara is incorrectly spelled in the\nimcra_counts dataset. With a little light wrangling, we can\nrectify this.\n\n\n# replace \"Pilbarra\" with \"Pilbara\" \nimcra_counts <- imcra_counts |> \n  mutate(cl966 = str_replace(string = cl966, \n                             pattern = \"Pilbarra\", \n                             replacement = \"Pilbara\"))\n\n# check names match\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\n\n\ncharacter(0)\n\nWell this is gratifying, now both sets of names match. Onward with\nour tidying!\nLet’s also check the distribution of counts in each dataset.\n\n\nhist(imcra_counts$count)\nhist(ibra_counts$count)\n\n\n\n\nThat’s a substantial skew to the right; let’s try a\nlog-transformation.\n\n\nhist(log(imcra_counts$count))\nhist(log(ibra_counts$count))\n\n\n\n\nMuch better. Let’s get joining!\nHere, we join the geospatial and numeric data. Along the way, we\nrename some columns, remove unnecessary columns, calculate counts as a\nproportion of the area of each region (so we’re plotting density of\nrecords, not counts of records), and convert the resulting dataframe\ninto a simple features object.\n\n\nimcra_join <- imcra_counts |> \n  full_join(y = imcra_shp, by = c(\"cl966\" = \"MESO_NAME\")) |> \n  rename(\"imcra\" = \"cl966\") |> \n  select(imcra, count, AREA_KM2, geometry) |> \n  mutate(density_log10 = log10(count / AREA_KM2)) |> \n  select(imcra, density_log10, geometry) |> \n  st_as_sf()\n\nibra_join <- ibra_counts |> \n  full_join(y = ibra_shp, by = c(\"cl1048\" = \"REG_NAME_7\")) |> \n  rename(\"ibra\" = \"cl1048\") |> \n  select(ibra, count, SQ_KM, geometry) |> \n  mutate(density_log10 = log10(count / SQ_KM)) |> \n  select(ibra, density_log10, geometry) |> \n  st_as_sf()\n\n\n\nPart 3: Where we map with\ngay abandon\nFinally, the reason we’re all here. Let’s get mapping! We’ll use the\nggnewscale package to apply different colour palettes to\nthe marine and terrestrial data.\n\n\n# add some custom fonts\nfont_add_google(\"Lato\", \"lato\")\nshowtext_auto()\n\n# map\nggplot() + \n  geom_sf(data = imcra_join,\n          aes(fill = density_log10),\n          colour = NA) +\n  scale_fill_distiller(name = \"IMCRA\",\n                       type = \"seq\",\n                       palette = \"BuPu\",\n                       direction = 1,\n                       labels = c(\"0.001\", \"0.01\", \"0.1\", \"1\", \"10\"),\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"bottom\",\n                                                title.position = \"left\",\n                                                title.hjust = 0.8,\n                                                title.vjust = 0.8)) +\n  new_scale_fill() +\n  geom_sf(data = ibra_join,\n          aes(fill = density_log10),\n          colour = NA) +\n  scale_fill_distiller(name = \"IBRA\",\n                       type = \"seq\",\n                       palette = \"YlOrBr\",\n                       direction = 1,\n                       labels = c(\"0.1\", \"1\", \"10\", \"100\"),\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"bottom\",\n                                                title.position = \"left\",\n                                                title.hjust = 0.8,\n                                                title.vjust = 0.8)) +  \n  annotate(\"text\", \n           x = 133, \n           y = -45, \n           label = \"No. of records per square km\",\n           size = 6) +\n  coord_sf(xlim = c(110, 155), ylim = c(-45, -10)) +\n  theme_void() +\n  theme(text = element_text(family = \"lato\"),\n        title = element_text(face = \"bold\"),\n        legend.position = \"bottom\",\n        legend.key.width = unit(12, 'mm'),\n        plot.background = element_rect(fill = 'white', colour = 'white'),\n        panel.background = element_rect(fill = 'white', colour = 'white'))\n\n\n\n\nSuccess!\nOne thing to note is that we didn’t necessarily have to use\nggnewscale here; we could just as easily have combined all\nthe data and plotted them on the same map without keeping the IBRA and\nIMCRA datasets separate. But, i) it’s nice to be able to differentiate\nmarine and terrestrial regions at a glance, and ii) using two legends\nalso makes it clear that there’s a stark difference in the number of\nplant records for marine and terrestrial regions.\nHappy plotting, everyone.\n\n\n\n",
    "preview": "posts/2022-05-23-multiple-scales-in-choropleth-maps-with-ggnewscale/distill-preview.png",
    "last_modified": "2022-05-25T15:43:48+10:00",
    "input_file": "multiple-scales-in-choropleth-maps-with-ggnewscale.knit.md"
>>>>>>> sb-ggnewscale
=======
    "contents": "\r\n\r\nContents\r\nMake a hexagon map\r\nDownload species data\r\nPlot number of species\r\nRender in 3D\r\n\r\n\r\n\r\n\r\n\r\n\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nDax\r\nKellie\r\n\r\n\r\nDate:\r\n\r\n23 May, 2022\r\n\r\n\r\n\r\n\r\n\r\nGrabbing people’s attention in a content-filled world can be\r\ndifficult. 3D maps can be particularly eye-catching, and thanks to the\r\nrayshader package\r\nit has become relatively simple to make a beautiful 3D plot from a plot\r\nmade with ggplot2.\r\nIn this post, we’ll make a 3D hex map of the number of plant species\r\nidentified from ALA observations since 2020. This map builds on a previous\r\nhex map post, but this time we will use a more unique “grid-to-data”\r\nmethod to download our data, where instead of plotting hexagons over our\r\nmap after extracting data, we’ll create a grid of hexagons that\r\nmap to Australia before extracting any data and query the ALA\r\nfor data for each hexagon. This method is cool because it saves\r\na lot of work wrangling your data to fit your plot later on.\r\nMake a hexagon map\r\nFirst let’s download the necessary packages\r\n\r\n\r\n# packages\r\nlibrary(galah)      # To download species data\r\nlibrary(rayshader)  # For 3d rendering\r\nlibrary(tidyverse)  # Data wrangling\r\nlibrary(here)       # Safe paths\r\nlibrary(sf)         # Spatial features\r\nlibrary(ozmaps)     # For map of oz\r\n\r\n\r\n\r\nNow let’s get a map of Australia from the ozmaps\r\npackage\r\n\r\n\r\n# get a map and project to WGS84\r\noz_wgs84 <- ozmap_data(data = \"country\") |>\r\n  st_transform(crs = st_crs(\"WGS84\"))\r\n\r\n## check map\r\nggplot(oz_wgs84) + geom_sf()\r\n\r\n\r\n\r\n\r\nNext let’s create our grid of hexagons and do some tidying to make\r\nsure the hexagons are only over the land\r\n\r\n\r\n# create grid\r\noz_grid <- st_make_grid(oz_wgs84,\r\n                        what = \"polygons\",\r\n                        cellsize = 1.0,\r\n                        square = FALSE,\r\n                        flat_topped = TRUE)\r\n\r\n# subset to grid cells that are within land\r\nkeep_hexes <- st_intersects(oz_grid, oz_wgs84)\r\nkeep_hexes <- as.data.frame(keep_hexes)$row.id\r\noz_grid <- oz_grid[keep_hexes]\r\n\r\n\r\n\r\nIf we plot our new oz_grid over our map, we can see how\r\nthe hexagons fill our map of Australia\r\n\r\n\r\n## check\r\nggplot() +\r\n  geom_sf(data = oz_wgs84) +\r\n  geom_sf(data = oz_grid, fill = NA, color = \"red\")\r\n\r\n\r\n\r\n\r\nDownload species data\r\nNow that we have our grid of hexagons, we can download data from the\r\nALA using the galah\r\npackage. Rather than downloading all data on the number of species\r\nidentified since 2020 and then plotting the data as hexagons, we will\r\nmake a function that sends individual queries to return the number of\r\nspecies identified within each hexagon.\r\nOur function get_counts() works in 3 parts:\r\nThe first part does some necessary editing of each Well Known\r\nText (WKT) string so that they are compatible with\r\ngalah.\r\nThe second part builds a query to download ALA data, beginning\r\nwith galah_call(). We add the WKT for each hexagon to our\r\nquery with galah_geolocate(), specify that we want to\r\nreturn only Plantae and Chlorophyta species with\r\ngalah_identify(), and filter to only records from 2020\r\nonwards with galah_filter(). We’ll also add\r\ngalah_filter(profile = \"ALA\") to use a standard ALA data\r\nquality filter (known in the ALA as as a data “profile”). We end our\r\nquery with atlas_counts(type = \"species\") to return counts\r\nof species, rather than counts of records (which is the default\r\nsetting).\r\nThe final part makes sure that if any hexagons have 0 species\r\nidentified, they will return a 0 rather than an NA, which\r\ntriggers an error in R.\r\n\r\n\r\nget_counts <- function(hexagon){\r\n  \r\n    # convert to wkt\r\n    wkt_string <- st_as_text(oz_grid[[hexagon]]) %>%\r\n      sub(\")))\", \"))\", .) %>%\r\n      sub(\"POLYGON \", \"POLYGON\", .)\r\n    \r\n    # get counts\r\n    result <- galah_call() |>\r\n      galah_geolocate(wkt_string) |>\r\n      galah_identify(\"plantae\", \"chlorophyta\") |>\r\n      galah_filter(profile = \"ALA\",\r\n                   decimalLongitude > 110,\r\n                   year >= 2020) |>\r\n      atlas_counts(type = \"species\", # get species counts\r\n                   limit = NULL)\r\n    \r\n    # light formatting to catch errors\r\n    if(is.null(result)){\r\n      tibble(count = NA, id = hexagon)\r\n    }else{\r\n      result$id <- hexagon\r\n      result\r\n    }\r\n  }\r\n\r\n\r\n\r\nWe can use purrr::map() to run this function recursively\r\nfor each hexagon. Then we can bind the separate lists into one\r\ndata.frame with purrr::map_dfr(). As oz_grid\r\nis a spatial object containing POLYGONs (which R treats\r\nslightly differently to a data.frame), we have to use\r\nseq_along(oz_grid) to enable us to run the function for\r\neach line, which corresponds to each POLYGON.\r\nIMPORTANT NOTE: This function will send\r\nlots of queries all at once to the ALA, so it is best\r\nto use restraint on how many times you run it because it can take a long\r\ntime and, if run many times in a row, can make it take even longer.\r\n\r\n\r\n# download number of species for each polygon\r\ncounts_list <- map(seq_along(oz_grid), get_counts)\r\n\r\n# bind lists to data frame\r\ncounts_df <- map_dfr(counts_list, rbind)\r\n\r\n\r\n\r\ncounts_df now contains a single count of species for\r\neach hexagon, indicated by a unique id\r\n\r\n\r\nhead(counts_df, 10L)\r\n\r\n\r\n# A tibble: 10 x 2\r\n   count    id\r\n   <dbl> <int>\r\n 1   396     1\r\n 2   303     2\r\n 3   457     3\r\n 4   178     4\r\n 5  1025     5\r\n 6   442     6\r\n 7   507     7\r\n 8   438     8\r\n 9   592     9\r\n10     5    10\r\n\r\nNow let’s merge our species counts in counts_df to our\r\noz_grid hexagons so we can plot them. To do so, we’ll\r\nconvert oz_grid to a tibble called oz_df, add\r\na blank count column, and fill that column with the species\r\ncounts in counts_df for each hexagon by\r\nid.\r\n\r\n\r\n# convert to tibble, attach counts\r\noz_df <- st_as_sf(oz_grid)\r\noz_df$count <- NA\r\noz_df$count[counts_df$id] <- counts_df$count\r\n\r\n\r\n\r\nLet’s see the final result by checking the hexagons with highest\r\nspecies counts\r\n\r\n\r\n# See top hexagons\r\noz_df %>%\r\n  arrange(desc(count)) %>%\r\n  head(10L)\r\n\r\n\r\nSimple feature collection with 10 features and 1 field\r\nGeometry type: POLYGON\r\nDimension:     XY\r\nBounding box:  xmin: 137.8823 ymin: -38.63203 xmax: 153.7594 ymax: -26.63203\r\nGeodetic CRS:  WGS 84\r\n   count                              x\r\n1   2543 POLYGON ((150.0066 -33.6320...\r\n2   2144 POLYGON ((150.8726 -34.1320...\r\n3   2073 POLYGON ((144.8105 -37.6320...\r\n4   2005 POLYGON ((150.0066 -34.6320...\r\n5   1959 POLYGON ((152.6047 -27.1320...\r\n6   1949 POLYGON ((152.6047 -28.1320...\r\n7   1804 POLYGON ((150.8726 -33.1320...\r\n8   1616 POLYGON ((151.7387 -27.6320...\r\n9   1604 POLYGON ((137.8823 -34.6320...\r\n10  1577 POLYGON ((143.9444 -38.1320...\r\n\r\nPlot number of species\r\nThe first step to making our 3D map is to make a 2D map with\r\nggplot2. I have set the fill of our map to use\r\noz_df’s count column and log transformed it to\r\nmake our final scale easier to read. The\r\nscale_fill_distiller() function has a nice “Greens” palette\r\nto make our plant species data look extra planty, and I have added\r\ncustom limits and labels to make sure the scale is understandable.\r\n\r\n\r\nhex_map <- ggplot() +\r\n  geom_sf(\r\n    data = oz_df,\r\n    mapping = aes(fill = log10(count + 1)), # log10 + 1 transformed\r\n    alpha = 1,\r\n    color = NA) +\r\n  scale_fill_distiller(name = \"Number of species \\n(since 1 Jan, 2020)\",\r\n                       type = \"seq\",\r\n                       direction = 1,\r\n                       limits = c(0,4),\r\n                       labels = c(\"10\", \"100\", \"1,000\"),\r\n                       palette = \"Greens\",\r\n                       # edit legend to be horizontal-bottom\r\n                       guide = guide_colorsteps(direction = \"horizontal\",\r\n                                                label.position = \"top\",\r\n                                                title.position = \"bottom\",\r\n                                                title.hjust = 0.5)\r\n                       ) +\r\n  # add map\r\n  geom_sf(data = oz_wgs84,\r\n          color = NA,\r\n          fill = NA)  +\r\n  # crop map\r\n  coord_sf(xlim = c(110, 155), \r\n           ylim = c(-45, -10)) +\r\n  # Adjust text and make aesthetic more minimal\r\n  theme(title = element_text(face = \"bold\"),\r\n        legend.title = element_text(size = 19),\r\n        legend.position = \"bottom\",\r\n        legend.key.width = unit(28, 'mm'),\r\n        legend.text = element_text(size = 16),\r\n        plot.background = element_rect(fill = 'white', colour = 'white'),\r\n        panel.background = element_rect(fill = 'white', colour = 'white'),\r\n        axis.title = element_blank()\r\n        )\r\n\r\nhex_map\r\n\r\n\r\n\r\n\r\nRender in 3D\r\nIt’s time to get 3-Dimensional! Using\r\nrayshader::plot_gg(), we can render a nice 3d version of\r\nour plot1\r\n\r\n\r\n# Render 3d plot\r\nplot_gg(hex_map, \r\n        width = 9, \r\n        height = 8,\r\n        scale = 300, # adjust height of 3D transformation\r\n        windowsize = c(1200, 960), # adjust window of rendered plot\r\n        fov = 75,    # adjust size/strength of blur around outer edges\r\n        zoom = 0.37, \r\n        theta = 320, # adjust left-right rotation of view\r\n        phi = 33)    # adjust height of view\r\n\r\n\r\n\r\n\r\n\r\n\r\nLooks great! Finally, we can save our plot using\r\nrender_snapshot()\r\n\r\n\r\n# save\r\nSys.sleep(0.2)\r\nrender_snapshot(here(\"folder\", \"subfolder\", \"3d-map.png\"))\r\n\r\n\r\n\r\nIn this case, a 3D map makes the areas with many and few species very\r\nnoticeable, which is a useful message to communicate.\r\nHowever, in general, one should be careful about using 3D plots\r\nwithout first considering the main messages they want people to take\r\naway from their data, and whether a 3D figure communicates this better\r\nthan a 2D alternative. People aren’t as good at quickly interpreting\r\ndifferences in height, shape or location in 3D plots compared to 2D\r\nplots. One reason for this weakness is that most 3D plots can only be\r\nviewed from a single angle. Depending on what angle the view point of\r\nthe plot is set to, the literal differences in heights or locations\r\nbetween shapes might change, even if their actual differences in the\r\ndata they represent don’t change. Looking at a 3D map from above, in the\r\nmiddle, or below changes how the shapes appear, and sometimes they may\r\nnot accurately represent the true differences between things\r\nyou want to compare in your plot. This quirk of 3D plots makes it easier\r\nfor people to misinterpret your plot and, as a result, take away the\r\nwrong message from the data (this idea is known as the principle\r\nof proportional ink (Tufte, 1983).\r\nCarl Bergstrom has written an\r\nexcellent explanation of why this principle matters in data\r\nvisualisation)\r\nEven so, 3D plots can be a beautiful way to see the number of plant\r\nspecies identified in the ALA since 2020. Even cooler, querying species\r\ndata from the ALA for each hexagon in our map with galah\r\ncan be an efficient way to download data and reduce data wrangling work\r\nlater on!\r\n\r\nIf you get a weird error related to\r\nthe scales package, updating to the latest version should\r\nfix it: https://github.com/tylermorganwall/rayshader/issues/181#:~:text=Update%20to%20the,install.packages(%27rayshader%27)\r\n↩︎\r\n",
    "preview": "https://github.com/AtlasOfLivingAustralia/ala-labs/blob/main/_posts/2022-05-17_3d-map/plants_3d.png",
    "last_modified": "2022-05-25T14:54:03+10:00",
    "input_file": {}
>>>>>>> ef29ff60f5e51984df210e9b6c0dcc1328f6e828
  },
  {
    "path": "posts/2021-04-14_hex-maps-for-species-occurrence-data/",
    "title": "Hex maps for species occurrence data",
    "description": "Hex maps are a neat way to represent spatial information. Here, we \nshow how to draw one using the most common species in the ALA database: \nthe iconic Australian Magpie.",
    "author": [
      {
        "name": "Matilda Stevenson",
        "url": {}
      }
    ],
    "date": "2022-02-25",
    "categories": [
      "Maps",
      "Eukaryota",
      "Animalia",
      "Chordata",
      "Aves"
    ],
    "contents": "\r\n\r\nContents\r\nGetting species occurrences\r\nPlotting binned data\r\n\r\n\r\n\r\n\r\n/* Remove distill metadata section */\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMatilda Stevenson, Martin Westgate, Dax Kellie\r\n\r\n\r\nDate:\r\n\r\n25 February, 2022\r\n\r\n\r\n\r\n\r\n\r\nThe Atlas of Living Australia (ALA) holds records of magpie sightings from a number data providers like iNaturalist, eBird and BirdLife Australia. Let’s make a visualisation of Australian Bird of the Year 2018 winner, Magpies, using records held in the ALA.\r\nGetting species occurrences\r\nAs with any R project, a good first step is to load the required packages\r\n\r\n\r\n# packages\r\nlibrary(ggplot2)\r\nlibrary(tidyr)\r\nlibrary(dplyr)\r\nlibrary(ozmaps)\r\nlibrary(sf)\r\nlibrary(hexbin)\r\n\r\n\r\n\r\nWe will use the {galah} package to download records.\r\nTo download species occurrence records, the {galah} package requires you to add an email registered with the ALA to galah_config(). If running this code yourself, you will need to add an email using the code below, substituting your email with myemail@email.com. This email address should be registered with the ALA, which you can do here\r\n\r\n\r\nlibrary(galah)\r\ngalah_config(email = \"myemail@email.com\")\r\n\r\n\r\n\r\nNow we can download magpie occurrence records by using atlas_occurrences(). Note that we also set our data ‘profile’ to ‘ALA’; this means we only download records that meet some basic data quality standards enforced by the atlas. This is optional, but tends to improve the quality of the data returned. (If you wish to see the data quality filters applied in the ALA profile, use search_profile_attributes(\"ALA\"))\r\n\r\n\r\nmagpie_occ <- galah_call() %>%\r\n  galah_identify(\"Cracticus tibicen\") %>%\r\n  galah_filter(profile = \"ALA\") %>%\r\n  atlas_occurrences()\r\n\r\n\r\n\r\nLet’s have a look at the first few rows of the data we’ve just downloaded:\r\n\r\n\r\nmagpie_occ %>% head()\r\n\r\n\r\n# A tibble: 6 x 7\r\n  decimalLatitude decimalLongitude eventDate            scientificName\r\n            <dbl>            <dbl> <chr>                <chr>         \r\n1           -45.0             169. \"\"                   Gymnorhina ti~\r\n2           -44.5             170. \"2018-10-27T21:44:0~ Gymnorhina ti~\r\n3           -44.1             170. \"2019-05-02T05:18:0~ Gymnorhina ti~\r\n4           -43.6             147. \"\"                   Gymnorhina ti~\r\n5           -43.6             147. \"\"                   Gymnorhina ti~\r\n6           -43.6             147. \"\"                   Gymnorhina ti~\r\n# ... with 3 more variables: taxonConceptID <chr>, recordID <chr>,\r\n#   dataResourceName <chr>\r\n\r\nFor the purpose of this exercise, we’re going to filter records not on the mainland or Tasmania.\r\n\r\n\r\nfiltered_occ <- magpie_occ %>% filter(decimalLongitude < 155,\r\n                                      decimalLongitude > 110,\r\n                                      decimalLatitude > -45,\r\n                                      decimalLatitude < -10)\r\n\r\n\r\n\r\nPlotting binned data\r\nThe easiest way to create a hex map is using the hexbin package\r\n\r\n\r\nggplot(filtered_occ) +\r\n  geom_hex(mapping = aes(x = decimalLongitude, y = decimalLatitude), \r\n           bins = 47, \r\n           colour = \"white\") +\r\n  ylim(-45, -10) +\r\n  xlim(110, 155) +\r\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\")) +\r\n  coord_fixed() +\r\n  theme_bw() +\r\n  theme(\r\n    panel.border = element_blank(),\r\n    panel.grid.major = element_blank(),\r\n    panel.grid.minor = element_blank(),\r\n    axis.text = element_blank(),\r\n    axis.ticks = element_blank(),\r\n    axis.title = element_blank(),\r\n    legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nWhile automated methods are nice, it might sometimes be useful to create our hexagons manually. We can do this by manually creating hexagons, linking them to a grid of Australia, and adding our data of magpie counts to set the fill color of those hexagons. To achieve this, we first convert the map of Australia provided by ozmaps to the same coordinate system as ALA data:\r\n\r\n\r\naus <- st_transform(ozmaps::ozmap_country, 4326)\r\n\r\n\r\n\r\nWe then transform points from our data frame of magpie occurrences to the correct coordinates\r\n\r\n\r\npoints <- lapply(1:nrow(filtered_occ), function(x) {\r\n  st_point(c(as.numeric(filtered_occ[x,'decimalLongitude']),\r\n                        as.numeric(filtered_occ[x,'decimalLatitude'])))\r\n})\r\n\r\n\r\n\r\nNow build the hexagonal grid\r\n\r\n\r\ngrid_all <- st_make_grid(aus, cellsize = 1, what = \"polygons\", square = FALSE)[aus]\r\ngridSF <- st_as_sf(grid_all)\r\n\r\n# Find which polygon each point is in\r\nintersect <- st_intersects(st_as_sfc(points) %>% st_set_crs(4326), gridSF)\r\n\r\n# count the number of points in each hexagon\r\nfreqs <- as.data.frame(table(unlist(intersect)), stringsAsFactors = FALSE)\r\n\r\nnames(freqs) <- c(\"hex_id\", \"count\")\r\n\r\n\r\n\r\nAdd our magpie counts data to the hexagons and fill hexagons without data\r\n\r\n\r\nfreqs$hex_id <- as.integer(freqs$hex_id)\r\n\r\n# fill in the values for hexagons with no records\r\nfilled_freqs <- freqs %>%\r\n  complete(hex_id = full_seq(c(1,925), 1), fill = list(count = 0))\r\ngridSF$n <- filled_freqs$count\r\n\r\n\r\n\r\nFinally, build the plot\r\n\r\n\r\nggplot() +\r\n  geom_sf(data = gridSF, aes(fill = n), size = .01) +\r\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\"), na.value = \"white\", trans = \"log2\") +\r\n  ylim(-45, -10) +\r\n  xlim(110, 155) +\r\n  theme_bw() +\r\n  theme(\r\n    panel.border = element_blank(),\r\n    panel.grid.major = element_blank(),\r\n    panel.grid.minor = element_blank(),\r\n    axis.text = element_blank(),\r\n    axis.ticks = element_blank(),\r\n    axis.title = element_blank(),\r\n    legend.position = \"none\") \r\n\r\n\r\n\r\n\r\nThat’s it! All the extra work does make a difference in this case, providing a better representation of the spread of Mapgies across Australia. Manually constructing hex maps can be useful in other circumstances, too. For example, if we wanted to compare the number of magpies to contextual information within each polygon (such as rainfall or human population data), then manually constructing our own hexagons could help us to combine data from different sources.\r\nA final point is that we could have achieved the same result by creating polygons first, then querying the ALA for the number of magpie records in each polygon using galah_geolocate(). That’s a bit more challenging, and not worthwhile in this case; but it can be an efficient solution where you require information on more species than there are polygons, for example. We’ll come back to this point in a future blog post.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-04-14_hex-maps-for-species-occurrence-data/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/",
    "title": "Sunburst plots for taxonomic data",
    "description": "Since version 1.3.1 of `galah`, it has been possible to download taxonomic\ndata using a 'tree' format from the `data.tree` package. Here I'll demonstrate\nsome ideas for plotting these trees using circular diagrams.",
    "author": [
      {
        "name": "Martin Westgate",
        "url": {}
      }
    ],
    "date": "2022-02-17",
    "categories": [
      "Trees",
      "Eukaryota",
      "Animalia",
      "Chordata"
    ],
    "contents": "\r\n\r\nContents\r\nDownloading taxonomic trees\r\nGetting plot-ready data\r\nDrawing\r\n\r\n\r\n\r\n\r\n\r\n\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMartin Westgate\r\n\r\n\r\nDate:\r\n\r\n17 February, 2022\r\n\r\n\r\n\r\n\r\n\r\nTaxonomy is pretty important at the ALA. Every occurrence record in the atlas is linked to a unique taxonomic identifier. These identifiers are themselves drawn from expertly curated taxonomic datasets. This system of classification is so important to our infrastructure that we have a special name for it; the ‘taxonomic backbone’. But what does it look like?\r\nVisualising trees is not particularly easy for me; I didn’t train in it, and the data structures involved can be a bit complex. More importantly, until recently it was difficult to download detailed taxonomic information from the ALA. Since version 1.3.1 of galah, however, it has been possible to download taxonomic trees using the atlas_taxonomy() function. Let’s have a go at visualising these trees now.\r\nDownloading taxonomic trees\r\nThe first step is to choose a taxonomic group to represent in tree form. I’ve chosen the chordates (Phylum Chordata) because they aren’t too large a group and the names are fairly well-known. We can specify this within galah using the function galah_identify. The second piece of information we need to supply is how far ‘down’ the tree to travel. I’ve chosen the Order level here using galah_down_to(order); while we could have gone to the Family or even Genus, trying to traverse too many levels (i.e. to Genus or Species) would take a very long time. A full list of accepted ranks can be found by calling show_all_ranks().\r\n\r\n\r\nlibrary(galah)\r\nchordate_orders <- galah_call() |>\r\n  galah_identify(\"chordata\") |>\r\n  galah_down_to(order) |>\r\n  atlas_taxonomy()\r\n\r\n\r\n\r\nThe object returned by atlas_taxonomy is slightly unusual; it uses the data.tree package, meaning that the dataset is literally structured like a tree. This is notably different from other representations of networks, such as you might find in igraph, for example. To get an idea of what the data look like, we can use the inbuilt print method for this data type:\r\n\r\n\r\nlibrary(data.tree)\r\nprint(chordate_orders, pruneMethod = \"dist\", limit = 10)\r\n\r\n\r\n                            levelName\r\n1  Chordata                          \r\n2   ¦--Cephalochordata               \r\n3   ¦   °--Amphioxi                  \r\n4   ¦       °--... 1 nodes w/ 0 sub  \r\n5   ¦--Tunicata                      \r\n6   ¦   ¦--Appendicularia            \r\n7   ¦   ¦   °--... 1 nodes w/ 0 sub  \r\n8   ¦   ¦--Ascidiacea                \r\n9   ¦   ¦   °--... 5 nodes w/ 0 sub  \r\n10  ¦   °--Thaliacea                 \r\n11  ¦       °--... 3 nodes w/ 0 sub  \r\n12  °--Vertebrata                    \r\n13      ¦--Agnatha                   \r\n14      ¦   °--... 2 nodes w/ 2 sub  \r\n15      °--Gnathostomata             \r\n16          °--... 5 nodes w/ 134 sub\r\n\r\nThis shows there are three nodes directly beneath Chordata in the taxonomic hierarchy, of which the largest (by number of sub-nodes) is the vertebrates (Vertebrata). There is a lot we could do with this tree; each node contains a unique taxonomic identifer, for example, meaning that we could use individual nodes to make new queries using galah. However, for now a useful task is simply to visualise the structure of the whole tree.\r\nGetting plot-ready data\r\nTaxonomic trees are complex. While all species have a Kingdom, Phylum, Order, Class and Family, there are many intermediate categories that are ‘optional’. In practice, this means that when we convert to a data.frame for plotting, there are a lot of missing values; nodes that apply to some rows but not others.\r\n\r\n\r\ndf_rank <- ToDataFrameTypeCol(chordate_orders, type = \"rank\")\r\ndf_rank[10:20,]\r\n\r\n\r\n   rank_phylum rank_subphylum rank_class           rank_informal\r\n10    Chordata       Tunicata  Thaliacea                    <NA>\r\n11    Chordata     Vertebrata       <NA>         Myxini, Agnatha\r\n12    Chordata     Vertebrata       <NA> Petromyzontida, Agnatha\r\n13    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n14    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n15    Chordata     Vertebrata   Amphibia           Gnathostomata\r\n16    Chordata     Vertebrata       Aves           Gnathostomata\r\n17    Chordata     Vertebrata       Aves           Gnathostomata\r\n18    Chordata     Vertebrata       Aves           Gnathostomata\r\n19    Chordata     Vertebrata       Aves           Gnathostomata\r\n20    Chordata     Vertebrata       Aves           Gnathostomata\r\n   rank_subclass rank_superorder rank_subinfraclass rank_infraclass\r\n10          <NA>            <NA>               <NA>            <NA>\r\n11          <NA>            <NA>               <NA>            <NA>\r\n12          <NA>            <NA>               <NA>            <NA>\r\n13  Lissamphibia            <NA>               <NA>            <NA>\r\n14          <NA> Labyrinthodonta               <NA>            <NA>\r\n15          <NA>       Salientia               <NA>            <NA>\r\n16    Neognathae            <NA>               <NA>            <NA>\r\n17    Neognathae            <NA>               <NA>            <NA>\r\n18 Palaeognathae            <NA>            Ratitae            <NA>\r\n19 Palaeognathae            <NA>            Ratitae            <NA>\r\n20          <NA>            <NA>               <NA>            <NA>\r\n   rank_subdivision zoology         rank_order\r\n10                     <NA>            Salpida\r\n11                     <NA>       Myxiniformes\r\n12                     <NA> Petromyzontiformes\r\n13                     <NA>              Anura\r\n14                     <NA>      Temnospondyli\r\n15                     <NA>       Sphenodontia\r\n16                     <NA>   Accipititrifomes\r\n17                     <NA>    Phaethontifomes\r\n18                     <NA>      Casuariifomes\r\n19                     <NA>   Dinornithiformes\r\n20                     <NA>       Anseriformes\r\n\r\nThese missing values will show up as empty sections in the resulting diagram, which isn’t ideal. Instead, we can build this data.frame so as to place all nodes in order by row, with empty ‘levels’ being placed at the end. This also avoids the problem where ‘unnamed’ ranks are grouped in the same column. To achieve this, we simply choose a different node attribute (level in this case) to supply to the type argument.\r\n\r\n\r\ndf_level <- ToDataFrameTypeCol(chordate_orders, type = \"level\")\r\ndf_level[10:20, ]\r\n\r\n\r\n    level_1    level_2       level_3        level_4\r\n10 Chordata   Tunicata     Thaliacea        Salpida\r\n11 Chordata Vertebrata       Agnatha         Myxini\r\n12 Chordata Vertebrata       Agnatha Petromyzontida\r\n13 Chordata Vertebrata Gnathostomata       Amphibia\r\n14 Chordata Vertebrata Gnathostomata       Amphibia\r\n15 Chordata Vertebrata Gnathostomata       Amphibia\r\n16 Chordata Vertebrata Gnathostomata           Aves\r\n17 Chordata Vertebrata Gnathostomata           Aves\r\n18 Chordata Vertebrata Gnathostomata           Aves\r\n19 Chordata Vertebrata Gnathostomata           Aves\r\n20 Chordata Vertebrata Gnathostomata           Aves\r\n              level_5          level_6          level_7 level_8\r\n10               <NA>             <NA>             <NA>    <NA>\r\n11       Myxiniformes             <NA>             <NA>    <NA>\r\n12 Petromyzontiformes             <NA>             <NA>    <NA>\r\n13       Lissamphibia            Anura             <NA>    <NA>\r\n14    Labyrinthodonta    Temnospondyli             <NA>    <NA>\r\n15          Salientia     Sphenodontia             <NA>    <NA>\r\n16         Neognathae Accipititrifomes             <NA>    <NA>\r\n17         Neognathae  Phaethontifomes             <NA>    <NA>\r\n18      Palaeognathae          Ratitae    Casuariifomes    <NA>\r\n19      Palaeognathae          Ratitae Dinornithiformes    <NA>\r\n20       Anseriformes             <NA>             <NA>    <NA>\r\n\r\nAnother problem in this dataset is the existence of duplicated taxonomic names. This happens because different authorities place the same taxon in different parts of the tree, and while the ALA tries to clean up these issues, some disagreements remain. The code below assumes that each name is only present once, so we have to remove duplicates to proceed. Fortunately there is a function in package base that flags duplcated values as TRUE and unique values as FALSE. We can use this function to identify rows where order is not unique.\r\n\r\n\r\nlibrary(dplyr)\r\nkeep_rows <- !duplicated(df_rank$rank_order)\r\ndf_rank <- filter(df_rank, keep_rows)\r\ndf_level <- filter(df_level, keep_rows)\r\n\r\n\r\n\r\nThe next step is to determine how to represent this structure in a plot. At the moment we can’t do this, because the data are in ‘wide’ format. Instead, we need to reorder our data so that each node/taxon is represented once, and other plotting aesthetics can be added as additional columns. To achieve this, we first convert to ‘long’ format, preserving information like what row and column each taxonomic label was recorded in.\r\n\r\n\r\ndf_long <- tibble(\r\n  row = rep(seq_len(nrow(df_level)), ncol(df_level)),\r\n  level = rep(seq_len(ncol(df_level)), each = nrow(df_level)),\r\n  taxon = do.call(c, df_level)) |> \r\n  filter(!is.na(taxon)) # remove missing values\r\n\r\n\r\n\r\nThen, we can summarize this plot so that each row is a single taxon, recording some metadata about rows and columns from the original dataset\r\n\r\n\r\ndf_plot <- df_long |>\r\n  group_by(taxon) |>\r\n  summarize(\r\n    xmin = min(row) - 1, \r\n    xmax = max(row), \r\n    ymin = level[1] - 1,\r\n    ymax = level[1])\r\n     \r\ndf_plot\r\n\r\n\r\n# A tibble: 161 x 5\r\n   taxon             xmin  xmax  ymin  ymax\r\n   <chr>            <dbl> <int> <dbl> <int>\r\n 1 Acanthopterygii     66    79     6     7\r\n 2 Accipititrifomes    15    16     5     6\r\n 3 Accipitriformes     21    22     4     5\r\n 4 Actinopterygii      56    96     4     5\r\n 5 Agnatha             10    12     2     3\r\n 6 Albuliformes        62    63     6     7\r\n 7 Amphibia            12    15     3     4\r\n 8 Amphioxi             0     1     2     3\r\n 9 Amphioxiformes       0     1     3     4\r\n10 Anguilliformes      63    64     6     7\r\n# ... with 151 more rows\r\n\r\nDrawing\r\nOur dataset now contains all the information we need to plot the structure of our taxonomic tree. As usual, we’re going to plot this with ggplot2.\r\n\r\n\r\nlibrary(ggplot2)\r\nggplot(df_plot) +\r\n  geom_rect(\r\n    mapping = aes(\r\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \r\n      group = taxon,\r\n      fill = ymax),\r\n    color = \"white\")\r\n\r\n\r\n\r\n\r\nWhile this is (probably) accurate, it’s not very informative. The most obvious missing element is labels; to add these, we’ll need to determine which nodes are ‘leaves’, and which are ‘branches’. We’ll also want to restrict labelling to larger branches, to avoid the text looking crowded. Finally, there is no need to label leaves with both a rectangle and text; so we’ll remove the leaf rectangles from the plot.\r\n\r\n\r\ndf_plot <- df_plot |> mutate(\r\n  x_dist = xmax - xmin,\r\n  is_leaf = taxon %in% df_rank$rank_order)\r\n\r\np <- ggplot() +\r\n  geom_rect(\r\n    data = filter(df_plot, !is_leaf),\r\n    mapping = aes(\r\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \r\n      group = taxon,\r\n      fill = ymax),\r\n    color = \"white\")\r\n\r\np +\r\n  # branch labels\r\n  geom_text(\r\n    data = filter(df_plot, x_dist > 5),\r\n    mapping = aes(\r\n      x = xmin + (x_dist * 0.5), \r\n      y = ymin + 0.5,\r\n      label = taxon),\r\n    color  = \"white\",\r\n    size = 3) +\r\n  # leaf labels\r\n  geom_text(\r\n    data = filter(df_plot, is_leaf),\r\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\r\n    angle = 90,\r\n    hjust = 0,\r\n    size = 2.5,\r\n    color = \"grey20\") \r\n\r\n\r\n\r\n\r\nThis is better, but not ideal. A much more pleasing look is to use coord_polar() to generate a circular plot; but this leads to linear text on a circular plot, which looks messy. Fortunately, the new package geomtextpath solves this problem. All we have to do is replace geom_text with geom_textpath, leaving all other code the same, and add coord_polar() at the end.\r\n\r\n\r\nlibrary(geomtextpath)\r\n\r\np <- p + \r\n  geom_textpath(\r\n    data = filter(df_plot, x_dist > 5),\r\n    mapping = aes(\r\n      x = xmin + (x_dist * 0.5), \r\n      y = ymin + 0.5,\r\n      label = taxon),\r\n    color  = \"white\",\r\n    size = 2.7) +\r\n  geom_textpath(\r\n    data = filter(df_plot, is_leaf),\r\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\r\n    angle = 90,\r\n    hjust = 0,\r\n    size = 2.3,\r\n    color = \"grey20\") +\r\n  coord_polar()\r\np\r\n\r\n\r\n\r\n\r\nFinally, we can add some finishing touches by changing the color scheme, hiding the background colors and legend, and resizing the y axis so all the labels are visible.\r\n\r\n\r\nlibrary(viridis)\r\n\r\np +\r\n  scale_fill_viridis(begin = 0, end = 0.9, direction = -1) +\r\n  lims(y = c(0, 9)) +\r\n  theme_void() + \r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nDone! This is a fun plot, but there are ways it could be expanded or improved, the most obvious of which is to find ways to add supplementary information. Wouldn’t it be great, for example, to add leaf-level record counts as marginal barplots? Or scale the size of segments to the number of records, rather than the number of clades? While none of these are impossible, I’m going to leave this here for now. I hope you like the result!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-20_creating-a-color-palette-from-an-image/",
    "title": "Creating a color palette from an image",
    "description": "There are hundreds of color palettes in the R ecosystem, but sometimes we\nmight want to use colors from a specific image. Here I show how to \nuse the `paletter` package to create a color palette for the 2020 Eucalypt of \nthe Year: the Western Australian Gimlet.",
    "author": [
      {
        "name": "Martin Westgate",
        "url": {}
      }
    ],
    "date": "2021-03-20",
    "categories": [
      "Summaries",
      "Eukaryota",
      "Plantae"
    ],
    "contents": "\r\n\r\nContents\r\nColors in R\r\nExtracting colors\r\nCreating a plot\r\n\r\n\r\n\r\n\r\n\r\nd-byline {\r\n    display: none;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAuthor:\r\n\r\nMartin Westgate\r\n\r\nDate:\r\n\r\nMarch 2021\r\n\r\n\r\n\r\nColors in R\r\nColor palettes are important to people, and the R ecosystem includes literally hundreds of possible palettes. If you want a “complete” list, go and check out Emil Hvitfeldt’s list of palettes here; but in practice there are only a few that we use routinely. Our default at ALA labs is to use viridis for continuous scales, because (to quote their CRAN page) it’s color-blind friendly, perceptually uniform, and pretty. The default purple-green-yellow color scheme is lovely, but I’m a big fan of ‘magma’, which has a black-purple-orange-yellow scheme\r\n\r\n\r\nlibrary(galah)\r\nlibrary(ggplot2)\r\nlibrary(viridis)\r\n\r\nrecords <- ala_counts(group_by = \"cl22\")\r\nrecords$State <- factor(seq_len(nrow(records)), labels = records$cl22) \r\n\r\nggplot(records, aes(x = State, y = log10(count), fill = count)) + \r\n  geom_bar(stat = \"identity\") +\r\n  coord_flip() +\r\n  scale_fill_viridis(option = \"magma\", begin = 0.10, end = 0.95) +\r\n  theme_bw() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nMy default for categorical color schemes is the ‘dark2’ palette from RColorBrewer; but given the subject matter of our work, it’s worth mentioning the wonderful feather package by Shandiya Balasubramaniam, which gives colors based on Australian bird plumage\r\n\r\n\r\n# remotes::install_github(repo = \"shandiya/feathers\")\r\nlibrary(feathers)\r\n\r\nrcfd <- ala_counts(\r\n  taxa = select_taxa(\"Rose-crowned Fruit-Dove\"),\r\n  group_by = \"cl22\")\r\nrcfd$State <- factor(seq_len(nrow(rcfd)), labels = rcfd$cl22) \r\n\r\nggplot(rcfd, aes(x = State, y = log10(count), fill = State)) + \r\n  geom_bar(stat = \"identity\") +\r\n  coord_flip() +\r\n  scale_fill_manual(values = get_pal(\"rose_crowned_fruit_dove\")) +\r\n  theme_bw() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nAll of this is fine, but what if you have a specific image that you want to take colors from? A logical choice is to pick the colors you want using an image editting program, but if we want to try something automated, there are options in R as well.\r\nExtracting colors\r\nNational Eucalypt Day aims to raise awareness about Eucalypts and celebrate their influence on the lives of Australians. In honour of National Eucalypt day, we wanted to created a plot based on occurrences data held in the Atlas of Living Australia, themed using colours from actual Eucalypts.\r\nWe used this image from a tweet by Dean Nicolle:\r\n\r\nHappy 'National Eucalypt Day'!The Western Australian gimlet (Eucalyptus salubris) has just been announced as Eucalypt of the Year for 2021. Renowned for its fluted, smooth, shiny, and colourful trunk & branches. pic.twitter.com/pOsufQtxWS— Dean Nicolle (@DeanNicolle1) March 22, 2021\r\n\r\n\r\nImage of Eucalyptus salubris by Dean NicolleFirst, get observations of the Eucalypt of the Year 2021 from ALA using the galah package. Specifically, we use ala_counts() to determine how many records of Eucalyptus salubris are held by the ALA:\r\n\r\n\r\nn_records <- ala_counts(taxa = select_taxa(\"Eucalyptus salubris\"))\r\n\r\n\r\n\r\nThen get a color scheme from images of the species in question using the paletter package (which needs to be installed from GitHub) \r\n\r\n\r\n# remotes::install_github(\"AndreaCirilloAC/paletter\")\r\nlibrary(paletter)\r\n\r\nimage_pal <- create_palette(\r\n  image_path = \"./data/Dean_Nicolle_Esalubris_image_small.jpeg\",\r\n  type_of_variable = \"categorical\",\r\n  number_of_colors = 15)\r\n\r\n\r\n\r\n\r\n\r\n\r\nNote that we downsized the image before running the paletter code, as large images take much longer to process.\r\nCreating a plot\r\nOnce we have this palette, the obvious question is what kind of plot to draw. We could have done a map, but those can be a bit boring. We decided to try something that represented the number of observations we had of this species at ALA, and included color, but was otherwise just a pretty picture that didn’t need to contain any further information. Rather than have a traditional x and y axis, therefore, we decided to try out the igraph package to plot the points in an interesting way.\r\nFirst, we create a vector containing as many points as we want to display, and distribute our colors among them as evenly as possible\r\n\r\n\r\n# create a vector to index colours\r\ncolour_index <- rep(seq_along(image_pal),\r\n  each = floor(n_records / length(image_pal)))\r\n# correct rounding errors\r\ncolour_index <- c(colour_index,\r\n  rep(length(image_pal), n_records - length(colour_index)))\r\n\r\n\r\n\r\nThen we can create a network using igraph, and use it to create a layout for our points\r\n\r\n\r\nlibrary(igraph)\r\n\r\ngraph_list <- lapply(c(1:15), function(a){\r\n  lookup <- which(colour_index == a)\r\n  return(data.frame(\r\n    from = lookup[c(1:(length(lookup)-1))],\r\n    to = lookup[c(2:length(lookup))]))\r\n  })\r\ngraph_df <- as.matrix(do.call(rbind, graph_list))         # build matrix\r\ncolour_graph <- graph_from_edgelist(graph_df)             # create network graph\r\n\r\n# convert to a set of point locations\r\ntest_layout <- as.data.frame(layout_nicely(colour_graph)) # convert to df\r\ncolnames(test_layout) <- c(\"x\", \"y\")                      # change colnames\r\ntest_layout$colour_index <- factor(colour_index)          # add colour_index col\r\n\r\n\r\n\r\nFinally, we draw the plot with ggplot2, removing axes with theme_void()\r\n\r\n\r\nggplot(test_layout, aes(x = x, y = y, colour = colour_index)) +\r\n  geom_point(size = 3, alpha = 0.9) +\r\n  scale_color_manual(values = image_pal) +\r\n  coord_fixed() +\r\n  theme_void() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nThat’s it! While I like the effect here, I think the paletter package is best suited to cases where there are large areas of strongly contrasting colors; it’s less ideal for images with subtle color differences. It also doesn’t appear to have been updated lately, which may mean it’s not being supported any more. But I’m happy with this plot, and would definitely consider using it again.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-20_creating-a-color-palette-from-an-image/distill-preview.png",
    "last_modified": "2022-04-21T15:32:59+10:00",
    "input_file": {}
  }
]
